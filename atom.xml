<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[有所为，有所不为]]></title>
  <link href="http://zhyu37.github.io/atom.xml" rel="self"/>
  <link href="http://zhyu37.github.io/"/>
  <updated>2015-10-15T11:27:15+08:00</updated>
  <id>http://zhyu37.github.io/</id>
  <author>
    <name><![CDATA[张昊煜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[转载 iOS开发总结之代码规范]]></title>
    <link href="http://zhyu37.github.io/blog/zhuan-zai-ioskai-fa-zong-jie-zhi-dai-ma-gui-fan.html/"/>
    <updated>2015-10-15T11:26:23+08:00</updated>
    <id>http://zhyu37.github.io/blog/zhuan-zai-ioskai-fa-zong-jie-zhi-dai-ma-gui-fan</id>
    <content type="html"><![CDATA[<hr />

<p>转载 <a href="http://www.cocoachina.com/ios/20151014/13678.html">http://www.cocoachina.com/ios/20151014/13678.html</a>
本文是投稿文章，作者：RylanJIN</p>

<blockquote><p>最近被安排fix项目的随机crash问题, 大大小小修复了差不多10个issue, 总结一下发现这些问题或多或少都是由代码习惯和编程规范引起的, 可见一个好的编码习惯是多么的重要! 趁着这两天休假将自己所认为的一些比较好的代码规范整理一下, 并结合之前遇到的实际case跟大家分享一下.</p></blockquote>

<p>命名规范</p>

<blockquote><p>总的来说, iOS命名两大原则是:可读性高和防止命名冲突(通过加前缀来保证). Objective-C 的命名通常都比较长, 名称遵循驼峰式命名法. 一个好的命名标准很简单, 就是做到在开发者一看到名字时, 就能够懂得它的含义和使用方法. 另外, 每个模块都要加上自己的前缀, 前缀在编程接口中非常重要, 可以区分软件的功能范畴并防止不同文件或者类之间命名发生冲突, 比如相册模块(PhotoGallery)的代码都以PG作为前缀: PGAlbumViewController, PGDataManager.</p></blockquote>

<p>1). 常量的命名</p>

<p>对于常量的命名最好在前面加上字母k作为标记. 如:</p>

<p>1
static const NSTimeInterval kAnimationDuration = 0.3;
定义作为NSDictionary或者Notification等的Key值字符串时加上const关键字, 以防止被修改. 如:</p>

<p>1
NSString *const UIApplicationDidEnterBackgroundNotification
Tips:</p>

<ol type="a">
<li>若常量作用域超出编译单元(实现文件), 需要在类外可见时, 使用extern关键字, 并加上该类名作为前缀. 如 extern NSString *const PGThumbnailSize</li>
</ol>


<p>II.全局常量(通知或者关键字等)尽量用const来定义. 因为如果使用宏定义, 一来宏可能被重定义. 二来引用不同的文件可能会导致宏的不同. P.S. 对于＃define也添加一下前缀k(强迫症, 哈哈&hellip;)</p>

<p>2). 枚举的命名</p>

<p>对于枚举类型, 经常会看到之前的C的定义方式:</p>

<p>1
2
3
4
5
typedef enum : {
    CameraModeFront,
    CameraModeLeft,
    CameraModeRight,
} CameraMode;
不知道是肿么了, 每次看到这种定义方式总是感觉怪怪的, 作为一个正宗的iOS开发者当然要以Objective-C的方式来定义啦, 哈哈&hellip; 那Objective-C是怎么定义的呢? 很简单, 到SDK里面看看Apple是怎么做滴:</p>

<pre><code>
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone,
    UIViewAnimationTransitionFlipFromLeft,
    UIViewAnimationTransitionFlipFromRight,
    UIViewAnimationTransitionCurlUp,
    UIViewAnimationTransitionCurlDown,
};
</pre>


<p></code>
这边需要注意的是: 枚举类型命名要加相关类名前缀并且枚举值命名要加枚举类型前缀.</p>

<p>3). 变量和对象的命名</p>

<p>给一个对象命名时建议采用修饰+类型的方式. 如果只用修饰命名会引起歧义, 比如title (这个到底是个NSString还是UILabel?). 同样的, 如果只用类型来命名则会缺失作用信息, 比如label (好吧, 我知道你是个UILabel, 但是我不知道它是用来做什么的呀?). So, 正确的命名方式为:</p>

<pre><code>
titleLabel    //表示标题的label,  是UILabel类型
confirmButton //表示确认的button, 是UIButton类型
</pre>


<p></code>
对于BOOL类型, 应加上is前缀, 比如- (BOOL)isEqualToString:(NSString <em>)aString这样会更加清晰. 如果某方法返回非属性的 BOOL 值, 那么应根据其功能, 选用 has 或 is 当前缀, 如- (BOOL)hasPrefix:(NSString </em>)aString</p>

<p>Tip: 如果某个命名已经很明确了, 为了简洁可以省去类型名. 比如scores, 很明显是个array了, 就不必命名成scoreArray了</p>

<p>编码规范</p>

<p>编码规范简单来说就是为了保证写出来的代码具备三个原则:可复用, 易维护, 可扩展. 这其实也是面向对象的基本原则. 可复用, 简单来说就是不要写重复的代码, 有重复的部分要尽量封装起来重用. 否则修改文件的时候得满地找相同逻辑的地方&hellip;这个就用no zuo no die来描述吧, 哈哈&hellip;易维护, 就是不要把代码复杂化, 不要去写巨复杂逻辑的代码, 而是把复杂的逻辑代码拆分开一个个小的模块, 这也是Do one thing的概念, 每个模块(或者函数)职责要单一, 这样的代码会易于维护, 也不容易出错. 可扩展则是要求写代码时要考虑后面的扩展需求, 这个属于架构层面的东东, 利用对应的设计模式来保证, 后面有机会单独写文探讨。</p>

<p>编码规范直接通过示例来介绍, 毕竟对于程序员来说一个Demo胜过千行文字(有同感的小伙伴让我看到你们的双手, 哈哈O(∩_∩)O~~). 下面的部分示例选自richieyang博文, 写的很好的一篇文章, 推荐大家看一下, 我自己也是受益匪浅.</p>

<p>1). 判断nil或者YES/NO</p>

<p>Preferred:</p>

<pre><code>
if (someObject) { ... } 
if (!someObject) { ... }
</pre>


<p></code>
Not preferred:</p>

<pre><code>
if (someObject == YES) { ...} 
if (someObject != nil) { ...}
</pre>


<p></code>
if (someObject == YES)容易误写成赋值语句, 自己给自己挖坑了&hellip;而且if (someObject)写法很简洁, 何乐而不为呢?</p>

<p>2). 条件赋值</p>

<p>Preferred:</p>

<pre><code>
result = object ? : [self createObject];
</pre>


<p></code>
Not preferred:</p>

<pre><code>
result = object ? object : [self createObject];
</pre>


<p></code>
如果是存在就赋值本身, 那就可以这样简写, 多简洁啊, 哈哈&hellip;</p>

<p>3). 初始化方法</p>

<p>Preferred:</p>

<pre><code>
NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve"];
NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal"};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingZIPCode = @10018;
</pre>


<p></code>
第一个好处还是简洁, 第二个好处是可以防止初始化进去nil值造成crash</p>

<p>4). 定义属性</p>

<p>Preferred:</p>

<pre><code>
@property (nonatomic, readwrite, copy) NSString *name;
</pre>


<p></code>
建议定义属性的时候把所有的参数写全, 尤其是如果想定义成只读的(防止外面修改)那一定要加上readonly, 这也是代码安全性的一个习惯.</p>

<p>如果是内部使用的属性, 那么就定义成私有的属性(定义到.m的class extension里面)</p>

<p>对于拥有Mutable子类型的对象(e.g. NSString, NSArray, NSDictionary)一定要定义成copy属性. Why? 示例: NSArray的array = NSMutableArray的mArray; 如果mArray在某个地方改变了, 那array也会跟着改变. So, make sense?</p>

<p>尽量不要暴露mutable类型的对象在public interface, 建议在.h定义一个Inmutable类型的属性, 然后在.m的get函数里面返回一个内部定义的mutable变量. Why? For security as well!</p>

<p>5). BOOL赋值</p>

<p>Preferred:</p>

<pre><code>
BOOL isAdult = age > 18;
</pre>


<p></code>
Not preferred:</p>

<pre><code>
BOOL isAdult;
if (age > 18)
{
    isAdult = YES;
}
else
{
    isAdult = NO;
}
</pre>


<p></code>
为什么要这么写呢, 我不告诉你, 哈哈哈&hellip;</p>

<p>6) 拒绝死值</p>

<p>Preferred:</p>

<pre><code>
if (car == Car.Nissan)
or
const int adultAge = 18; if (age > adultAge) { ... }
</pre>


<p></code>
Not preferred:</p>

<pre><code>
if (carName == "Nissan")
or
if (age > 18) { ... }
</pre>


<p></code>
死值每次修改的时候容易被遗忘, 地方多了找起来就悲剧了. 而且定义成枚举或者static可以让错误发生在编译阶段. 另外仅仅看到一个数字, 完全不知道这个数字代表的意义. 纳尼?</p>

<p>7). 复杂的条件判断</p>

<p>Preferred:</p>

<pre><code>
if ([self canDeleteJob:job]) { ... }     
    
- (BOOL)canDeleteJob:(Job *)job
{
    BOOL invalidJobState = job.JobState == JobState.New
                          || job.JobState == JobState.Submitted
                          || job.JobState == JobState.Expired;
    BOOL invalidJob = job.JobTitle && job.JobTitle.length;
     
    return invalidJobState || invalidJob;
}
</pre>


<p></code>
Not preferred:</p>

<pre><code>
if (job.JobState == JobState.New
    || job.JobState == JobState.Submitted
    || job.JobState == JobState.Expired
    || (job.JobTitle && job.JobTitle.length))
{
    //....
}
</pre>


<p></code>
清晰明了, 每个函数DO ONE THING!</p>

<p>8). 嵌套判断</p>

<p>Preferred:</p>

<pre><code>
if (!user.UserName) return NO;
if (!user.Password) return NO;
if (!user.Email) return NO;
 
return YES;
</pre>


<p></code>
Not preferred:</p>

<pre><code>
BOOL isValid = NO;
if (user.UserName)
{   
    if (user.Password)
    {
        if (user.Email) isValid = YES;
    }
     
}
return isValid;
</pre>


<p></code>
一旦发现某个条件不符合, 立即返回, 条理更清晰</p>

<p>9). 参数过多</p>

<p>Preferred:</p>

<pre><code>
- (void)registerUser(User *user)
{
    // to do...
      
}
</pre>


<p></code>
Not preferred:</p>

<pre><code>
- (void)registerUserName:(NSString *)userName
                password:(NSString *)password 
                   email:(NSString *)email
{
     // to do...
}
</pre>


<p></code>
当发现实现某一功能需要传递的参数太多时, 就预示着你应该聚合成一个model类了&hellip;这样代码更整洁, 也不容易因为参数太多导致出错。</p>

<p>10). 回调方法</p>

<p>Preferred:</p>

<pre><code>
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</pre>


<p></code>
函数调用的可知性, 回调时被调用者要知道其调用者, 方便信息的传递, 所以建议在回调方法中第一个参数中加上调用者。</p>

<p>Well, 不知不觉已经整理了10个了, 额, 太多了, 不知道童鞋们还有木有耐心看了, 好吧, 这一段就到此为止吧, 下面写一下block的编码规范, 各位看官, 预知后事如何, 且继续look look, 哈哈&hellip;</p>

<p>Block的循环引用问题</p>

<p>Block确实是个好东西, 但是用起来一定要注意循环引用的问题, 否则一不小心你就会发现, Oh My God, 我的dealloc肿木不走了&hellip;</p>

<pre><code>
__weak typeof(self) weakSelf = self;
dispatch_block_t block =  ^{
    [weakSelf doSomething]; // weakSelf != nil
    // preemption, weakSelf turned nil
    [weakSelf doSomethingElse]; // weakSelf == nil
};
</pre>


<p></code>
如此在上面定义一个weakSelf, 然后在block体里面使用该weakSelf就可以避免循环引用的问题. 那么问题来了&hellip;是不是这样就完全木有问题了? 很不幸, 答案是NO, 还是有问题。问题是block体里面的self是weak的, 所以就有可能在某一个时段self已经被释放了, 这时block体里面再使用self那就是nil, 然后&hellip;然后就悲剧了&hellip;那么肿么办呢?</p>

<pre><code>
__weak typeof(self) weakSelf = self;
myObj.myBlock =  ^{
    __strong typeof(self) strongSelf = weakSelf;
    if (strongSelf) {
      [strongSelf doSomething]; // strongSelf != nil
      // preemption, strongSelf still not nil
      [strongSelf doSomethingElse]; // strongSelf != nil
    }
    else {
        // Probably nothing...
        return;
         
    }
};
</pre>


<p></code>
解决方法很简单, 就是在block体内define一个strong的self, 然后执行的时候判断下self是否还在, 如果在就继续执行下面的操作, 否则return或抛出异常.</p>

<p>什么情况下会出现block里面self循环引用的问题? 这个问题问的好, 哈哈&hellip;简单来说就是双边引用, 如果block是self类的property (此时self已经retain了block), 然后在block内又引用了self, 这个情况下就肯定会循环引用了&hellip;</p>

<p>P.S. RAC里面有定义好的@weakify(self)和@strongify(self), 用起来灰常灰常的方便, 劝君尝试一下^_^</p>

<p>那些年遇到的Crash</p>

<p>多线程同步问题造成的Crash
这个其实还蛮常见的, 尤其是在多线程泛滥使用的今天&hellip;你可以使用多线程, 但你要知道保护它呀, 哈哈. 对于数据源或model类一定要注意多线程同时访问的情况, 我个人比较喜欢用GCD的串行队列来同步线程.</p>

<p>Observer的移除
现在的代码里面很多需要用到Observer, 根据被观察对象的状态来相应的Update UI或者执行某个操作. 注册observer很简单, 但是移除的时候就出问题了, 要么是忘记移除observer了, 要么是移除的时机不对. 如果某个被观察对象已经被释放了, observer还在, 那结果只能是crash了, 所以切记至少在dealloc里面移除一下observer&hellip;</p>

<p>NSArray, NSDictionary成员的判空保护
在addObject或insertObject到NSArray或者NSDictionary时最好加一下判空保护, 尤其是网络相关的逻辑, 如果网络返回为空(jason解析出来为空), 但你还是毅然决然的add到array里面, 那么&hellip;</p>

<p>最后一点就是commit代码之前一定要保证木有warning, 木有内存泄露, 确保都OK之后再上传代码. 其实很简单, 上传代码之前Command + Shift + B静态分析一下, 看看有木有什么issue&hellip;就先写这么多吧, 以后遇到更多的坑后, 我一定会爬出来再过来补充的, to be continued&hellip;</p>

<p>References:</p>

<p><a href="http://www.cnblogs.com/richieyang/p/4840614.html">http://www.cnblogs.com/richieyang/p/4840614.html</a></p>

<p><a href="http://blog.xcodev.com/archives/objective-c-naming/">http://blog.xcodev.com/archives/objective-c-naming/</a></p>

<p><a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios本地时间的运用NSDate]]></title>
    <link href="http://zhyu37.github.io/blog/iosben-di-shi-jian-de-yun-yong-nsdate.html/"/>
    <updated>2015-10-15T00:06:15+08:00</updated>
    <id>http://zhyu37.github.io/blog/iosben-di-shi-jian-de-yun-yong-nsdate</id>
    <content type="html"><![CDATA[<hr />

<h2>ios本地时间的运用NSDate</h2>

<blockquote><p>看来NSDate之后感慨大一时候，在ACM中写敢于时间的问题，想想感觉当时太单纯，哈哈。</p></blockquote>

<p>NSDate的初始化</p>




<pre><code>
//获取当前日期
NSDate *now = [NSDate date];

//如果想获取几天后的时间，如果放在大一我还在傻乎乎的判断每个月有多少天哪一年是闰年，当然傻乎乎的时光是美好的。。。。。
NSTimeInterval day = 24 * 60 * 60; 

NSDate *will = [[NSDate alloc] initWithTimeInterval:day sinceDate:[NSDate date]];

//如果出现了 时区的问题
NSTimeZone *zone = [NSTimeZone systemTimeZone];
         
NSInteger interval = [zone secondsFromGMTForDate: date];
         
NSDate *localDate = [date  dateByAddingTimeInterval: interval];

</pre>


<p></code></p>

<p>当然NSDate -> NSString 的转换也是不可或缺的</p>




<pre><code>
NSDateFormatter *dateFormatter =[[NSDateFormatter alloc] init];
 
// 设置日期格式
[dateFormatter setDateFormat:@"年月日 YYYY/mm/dd 时间 hh:mm:ss"];
         
NSString *dateString = [dateFormatter stringFromDate:[NSDate date]];
         
// 打印结果：dateString = 年月日 2013/10/16 时间 05:15:43
        NSLog(@"dateString = %@",dateString);
         
// 设置日期格式
[dateFormatter setDateFormat:@"YYYY-MM-dd"];
         
NSString *year = [dateFormatter stringFromDate:[NSDate date]];
         
// 打印结果：年月日 year = 2013-08-16
NSLog(@"年月日 year = %@",year);
         
// 设置时间格式
[dateFormatter setDateFormat:@"hh:mm:ss"];
         
NSString *time = [dateFormatter stringFromDate:[NSDate date]];

// 打印结果：时间 time = 05:15:43
NSLog(@"时间 time = %@",time);
</pre>


<p></code></p>

<p>两个时间的比较</p>




<pre><code>
// 当前时间
NSDate *currentDate = [NSDate date];
         
// 比当前时间晚一个小时的时间
NSDate *laterDate = [[NSDate alloc] initWithTimeInterval:60*60 sinceDate:[NSDate date]];
         
// 比当前时间早一个小时的时间
NSDate *earlierDate = [[NSDate alloc] initWithTimeInterval:-60*60 sinceDate:[NSDate date]];
         
// 比较哪个时间迟
if ([currentDate laterDate:laterDate]) {
// 打印结果：current-2013-08-16 09:25:54 +0000比later-2013-08-16 10:25:54 +0000晚
NSLog(@"current-%@比later-%@晚",currentDate,laterDate);
}
         
// 比较哪个时间早
if ([currentDate earlierDate:earlierDate]) {
// 打印结果：current-2013-08-16 09:25:54 +0000 比 earlier-2013-08-16 08:25:54 +0000 
NSLog(@"current-%@ 比 earlier-%@ 早",currentDate,earlierDate);
}
         
if([currentDatecompare:earlierDate]==NSOrderedDescending) 
{
// 打印结果
NSLog(@"current 晚");
}
if ([currentDate compare:currentDate]==NSOrderedSame) 
{
// 打印结果
NSLog(@"时间相等");
}
if ([currentDate compare:laterDate]==NSOrderedAscending) {
// 打印结果
NSLog(@"current 早");
}
</pre>


<p></code></p>

<h2>See You</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[菜鸟的努力——真实项目的搭]]></title>
    <link href="http://zhyu37.github.io/blog/cai-niao-de-nu-li-zhen-shi-xiang-mu-de-da.html/"/>
    <updated>2015-10-14T23:33:58+08:00</updated>
    <id>http://zhyu37.github.io/blog/cai-niao-de-nu-li-zhen-shi-xiang-mu-de-da</id>
    <content type="html"><![CDATA[<hr />

<h2>菜鸟的努力——真实项目的搭建</h2>

<blockquote><p>作为我的第一个真实的商业项目，让我来解析一下项目的搭建。
这个项目的class文件下分为<code>Other</code> <code>HTTP</code> <code>一些主要的模块</code>
让我来重点解析一下前两个模块</p></blockquote>

<p>Other文件夹相当于是项目的后勤部分，一些需要的辅助东西都可以在这里找到</p>




<p>Base</p>


<p>Base--Controller</p>


<p>Base--Controller--BaseViewColler</p>


<pre><code>
在这个类里面主要是对UIViewController的修改

- (void)viewDidLoad
{
    [super viewDidLoad];
    //设定好的背景颜色
    self.view.backgroundColor = kColorBackground;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    //当点击背景的时候自动丧失焦点
    [self.view endEditing:YES];
}
</pre>


<p></code></p>

<p><Base--Controller--BaseNavigationController></p>

<pre><code>
在这个类里面 主要是对导航栏的修改  和  返回按钮的  自定义

//初始化时候调用
+ (void)initialize{
    [self setupNavTheme];
    [self setupBarButton];
}

+ (void)setupBarButton{
    UIBarButtonItem *barButton = [UIBarButtonItem appearance];
    
    NSMutableDictionary *disabledAttrs = [NSMutableDictionary dictionary];
    disabledAttrs[NSForegroundColorAttributeName] = [UIColor lightGrayColor];
    [barButton setTitleTextAttributes:disabledAttrs forState:UIControlStateDisabled];
}

+ (void)setupNavTheme{
    UINavigationBar *navBar = [UINavigationBar appearance];
    
    navBar.tintColor = [UIColor whiteColor];
    //背景颜色
    navBar.barTintColor = kColorNavBar;
    // 设置标题文字颜色
    NSMutableDictionary *attrs = [NSMutableDictionary dictionary];
    attrs[NSForegroundColorAttributeName] = [UIColor whiteColor];
    attrs[NSFontAttributeName] = [UIFont systemFontOfSize:18];
    [navBar setTitleTextAttributes:attrs];
    
    // 2.设置BarButtonItem的主题
    UIBarButtonItem *item = [UIBarButtonItem appearance];
    // 设置文字颜色
    NSMutableDictionary *itemAttrs = [NSMutableDictionary dictionary];
    itemAttrs[NSForegroundColorAttributeName] = [UIColor whiteColor];
    itemAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14];
    [item setTitleTextAttributes:itemAttrs forState:UIControlStateNormal];
}


- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated{
    if (self.viewControllers.count > 0) {
        viewController.hidesBottomBarWhenPushed = YES;
        
       UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
        [button setBackgroundImage:[UIImage imageNamed:@"nav_back"] forState:UIControlStateNormal];
        [button setBackgroundImage:[UIImage imageNamed:@"nav_back"] forState:UIControlStateHighlighted];
        button.frame = (CGRect){CGPointZero, button.currentBackgroundImage.size};
        [button addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchUpInside];
        ;
        
        
       viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:button];
        
    }
    [super pushViewController:viewController animated:YES];
}

- (void)back{
    [self popViewControllerAnimated:YES];
}
</pre>


<p></code></p>

<p>Base--Controller--BaseTabBarController</p>




<pre><code>
在这个类里 主要是 写了 这个项目中几个标签的初始化

/**
 *  整个生命周期只会调用一次
 */
+ (void)initialize
{
    [UITabBar appearance].translucent = NO;
    [UITabBar appearance].barTintColor = kColorTabBar;
}

- (instancetype)init
{
    if (self = [super init])
    {
        [self setupChildViewControllers];
    }
    return self;
}

//#pragma mark - Life Circle
- (void)viewDidLoad
{
    [super viewDidLoad];
}

//#pragma mark - private methods
/**
 *  初始化子控制器
 */
- (void)setupChildViewControllers
{
    // 初始化子控制器
    // 治未病
    TDCTreatViewController *treatVC = [[TDCTreatViewController alloc] init];
    BaseNavigationController *treatNavVC = [self generateViewController:treatVC withTabBarItemTitle:@"治未病" tabBarItemTitleNormalColor:kTabBarItemTitleNormalColor tabBarItemNormalImage:@"tabBar_treat" tabBarItemTitleSelectedColor:kTabBarItemTitleSelectedColor tabBarItemSelectedImage:@"tabBar_treat_selected"];
    
   // 更多
    TDCMoreViewController *discoverVC = [[TDCMoreViewController alloc] init];
    BaseNavigationController *discoverNavVC = [self generateViewController:discoverVC withTabBarItemTitle:@"更多" tabBarItemTitleNormalColor:kTabBarItemTitleNormalColor tabBarItemNormalImage:@"tabBar_more" tabBarItemTitleSelectedColor:kTabBarItemTitleSelectedColor tabBarItemSelectedImage:@"tabBar_more_selected"];
    
   // 我的
    TDCMineViewController *mineVC = [[TDCMineViewController alloc] init];
    BaseNavigationController *mineNavVC = [self generateViewController:mineVC withTabBarItemTitle:@"我的" tabBarItemTitleNormalColor:kTabBarItemTitleNormalColor tabBarItemNormalImage:@"tabBar_mine" tabBarItemTitleSelectedColor:kTabBarItemTitleSelectedColor tabBarItemSelectedImage:@"tabBar_mine_selected"];
    
    
   self.viewControllers = @[treatNavVC,discoverNavVC,mineNavVC];
}

/**
 *  快速创建TaBarCotroller的子控制器
 *
 *  @param vc                           子控制器
 *  @param tabBarItemTitle              子控制器tabBarItem的文字
 *  @param tabBarItemTitleNormalColor   子控制器tabBarItem的文字颜色
 *  @param tabBarItemNormalImage        子控制器tabBarItem的图片
 *  @param tabBarItemTitleSelectedColor 子控制器tabBarItem的选中文字颜色
 *  @param tabBarItemSelectedImage      子控制器tabBarItem的选中图片
 *
 *  @return 封装好了的一个自控制器
 */
- (BaseNavigationController *)generateViewController:(UIViewController *)vc withTabBarItemTitle:(NSString *)tabBarItemTitle tabBarItemTitleNormalColor:(UIColor *)tabBarItemTitleNormalColor tabBarItemNormalImage:(NSString *)tabBarItemNormalImage
    tabBarItemTitleSelectedColor:(UIColor *)tabBarItemTitleSelectedColor  tabBarItemSelectedImage:(NSString *)tabBarItemSelectedImage
{
    // 用vc压入导航控制器栈
    BaseNavigationController *navVC = [[BaseNavigationController alloc] initWithRootViewController:vc];
    
                              
   // 设置文字
    navVC.tabBarItem.title = tabBarItemTitle;
    
   // 设置文字颜色
    [navVC.tabBarItem setTitleTextAttributes:@{NSForegroundColorAttributeName:kTabBarItemTitleNormalColor,NSFontAttributeName:kTabBarItemTitleFont} forState:UIControlStateNormal];
    [navVC.tabBarItem setTitleTextAttributes:@{NSForegroundColorAttributeName:kTabBarItemTitleSelectedColor,NSFontAttributeName:kTabBarItemTitleFont} forState:UIControlStateSelected];
    
   // 设置图片
   [navVC.tabBarItem setImage:[[UIImage imageNamed:tabBarItemNormalImage] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];
    [navVC.tabBarItem setSelectedImage:[[UIImage imageNamed:tabBarItemSelectedImage] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];
    
   return navVC;
}

</pre>


<p></code></p>

<h2>See You</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios8之UIAlertController]]></title>
    <link href="http://zhyu37.github.io/blog/ios8zhi-uialertcontroller.html/"/>
    <updated>2015-10-13T17:16:02+08:00</updated>
    <id>http://zhyu37.github.io/blog/ios8zhi-uialertcontroller</id>
    <content type="html"><![CDATA[<hr />

<h2>UIAlertController</h2>

<blockquote><p>UIAlertController 作为ios8新出现的controller还是很值得学习的，它融合了之前的UIAlertView 和  UIActionSheet.</p></blockquote>

<P>先来写个简单的小例子</P>




<pre><code>
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"title" message:@"message" preferredStyle:UIAlertControllerStyleAlert];

UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
            
}];

 UIAlertAction *commitAction = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) {
 
}];

[alertController addAction:cancelAction];
[alertController addAction:commitAction];
[self presentViewController:alertController animated:YES completion:nil];
</pre>


<p></code></p>

<p><img src="http://zhyu37.github.io/Users/zhanghaoyu/octopress/source/_posts/image/UIAlertConller1.png" alt="样例" /></p>

<p>在UIAlertController中添加一个输入框</p>




<pre><code>
@property (nonatomic, strong) UIAlertAction *secureTextAlertAction;
</pre>


<p></code></p>

<pre><code>
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"title" message:@"message" preferredStyle:UIAlertControllerStyleAlert];

 // Add the text field for the secure text entry.
    [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        // Listen for changes to the text field's text so that we can toggle the current
        // action's enabled property based on whether the user has entered a sufficiently
        // secure entry.
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleTextFieldTextDidChangeNotification:) name:UITextFieldTextDidChangeNotification object:textField];
        //每输入一个字符就会变成点
         textField.secureTextEntry = YES;
 }];

UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
        [[NSNotificationCenter defaultCenter] removeObserver:self name:UITextFieldTextDidChangeNotification object:alertController.textFields.firstObject];
    }];

 UIAlertAction *commitAction = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UITextFieldTextDidChangeNotification object:alertController.textFields.firstObject];
}];

// The text field initially has no text in the text field, so we'll disable it.
    commitAction.enabled = NO;
    
// Hold onto the secure text alert action to toggle the enabled/disabled state when the text changed.
    self.secureTextAlertAction = commitAction;

[alertController addAction:cancelAction];
[alertController addAction:commitAction];
[self presentViewController:alertController animated:YES completion:nil];

</pre>


<p></code></p>

<pre><code>
- (void)handleTextFieldTextDidChangeNotification:(NSNotification *)notification
{
    UITextField *textField = notification.object;
    
   // Enforce a minimum length of >= 5 characters for secure text alerts.
    self.secureTextAlertAction.enabled = textField.text.length >= 5;
}
</pre>


<p></code></p>

<h3>See You</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSNotificationCenter小结]]></title>
    <link href="http://zhyu37.github.io/blog/nsnotificationcenterxiao-jie.html/"/>
    <updated>2015-10-12T23:41:11+08:00</updated>
    <id>http://zhyu37.github.io/blog/nsnotificationcenterxiao-jie</id>
    <content type="html"><![CDATA[<hr />

<h2>NSNotification 消息机制</h2>

<blockquote><p>最近在项目中发现这个NSNotification还是很好用的。那我就简单介绍一下步骤，先要注册对象，当有人post的时候调用注册的方法，当然不能忘记<code>remove</code>注册了的对象。</p></blockquote>

<p>注册对象</p>




<pre><code>
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@"test" object:nil];
}
</code></pre>




<p>当对象被post之后  会调用 写好的test方法</p>




<pre><code>
 [[NSNotificationCenter defaultCenter] postNotificationName:@"test" object:nil];
    });
</pre>


<p></code></p>

<p>删除对象</p>




<pre><code>
[[NSNotificationCenter defaultCenter] removeObserver:self name:@"test" object:nil];
</code></pre>


<p><code>注册和删除对象 一定要成对出现  ，当然也可以在dealloc里面 一起删除</code></p>

<pre><code>
- (void)dealloc{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [super dealloc];
}
</pre>


<p></code></p>

<p>在这个类的.h 文件中添加下面的的外部申明</p>




<pre><code>
extern NSString * const testNotification;
</pre>


<p></code></p>

<p>在.m中定义常量</p>




<pre><code>
NSString * const testNotification = @"BNRColorChanged";
</pre>


<p></code></p>

<p><code>如果安上面的申请方法 我们的注册 和 删除对象也可以改变一下</code></p>

<pre><code>

[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:testNotification object:nil];
}

post 删除 同理

</pre>


<p></code></p>

<h4>See You</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C 2.0--10.在既有类中使用关联对象存放自定义数据]]></title>
    <link href="http://zhyu37.github.io/blog/effective-objective-c-2-dot-0-10-dot-zai-ji-you-lei-zhong-shi-yong-guan-lian-dui-xiang-cun-fang-zi-ding-yi-shu-ju.html/"/>
    <updated>2015-10-10T00:47:52+08:00</updated>
    <id>http://zhyu37.github.io/blog/effective-objective-c-2-dot-0-10-dot-zai-ji-you-lei-zhong-shi-yong-guan-lian-dui-xiang-cun-fang-zi-ding-yi-shu-ju</id>
    <content type="html"><![CDATA[<p>当我们想在对象中存放其他信息时，一般会采用创建其子类后改用这个子类对象。然而并非所有情况都可以这么做。so Object-c中有一个强大的特性——关联对象(Associated Object)</p>

<p>关联策略</p>

<p>关联策略
等价属性
说明</p>

<p>OBJC_ASSOCIATION_ASSIGN
@property (assign) or @property (unsafe_unretained)
弱引用关联对象</p>

<p>OBJC_ASSOCIATION_RETAIN_NONATOMIC
@property (strong, nonatomic)
强引用关联对象，且为非原子操作</p>

<p>OBJC_ASSOCIATION_COPY_NONATOMIC
@property (copy, nonatomic)
复制关联对象，且为非原子操作</p>

<p>OBJC_ASSOCIATION_RETAIN
@property (strong, atomic)
强引用关联对象，且为原子操作</p>

<p>OBJC_ASSOCIATION_COPY
@property (copy, atomic)
复制关联对象，且为原子操作</p>

<p>其中，第 2
 种与第 4
 种、第 3
 种与第 5
 种关联策略的唯一差别就在于操作是否具有原子性。由于操作的原子性不在本文的讨论范围内，所以下面的实验和讨论就以前三种以例进行展开。</p>

<p>方法</p>

<p>//以给定的键和策略为某对象设置关联对象值
void objc setAssociatedObject(id object, const void *key, id value, objc AssociationPolicy policy);</p>

<p>//根据给给定的键从某对象中获取相应地关联对象值
 id objc getAssociatedObject(id object, const void *key);</p>

<p>//移除所指定对象的全部关联对象
void objc removeAssociatedObjects(id object);</p>

<p>key 值</p>

<p>关于前两个函数中的 key
 值是我们需要重点关注的一个点，这个 key 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 key
 值：</p>

<ol>
<li>声明 static char kAssociatedObjectKey;，使用 &amp;kAssociatedObjectKey 作为 key 值;</li>
<li>声明 static void *kAssociatedObjectKey = &kAssociatedObjectKey; ，使用 kAssociatedObjectKey 作为 key值；</li>
<li>用 selector，使用 getter方法的名称作为 key值</li>
</ol>


<p>我们把对象想象成NSDicitionary,把关联对象想象成字典的条目。存取关联对象的值就相当于NSDicitionary中调用[object setObject:value forKey:key]和[object setObjectForKey:key]。两者之间有个最重要的差别key(键) 是一个不透明的指针。所以通常使用静态全局变量做键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[菜鸟的努力-ios的HTTP搭建]]></title>
    <link href="http://zhyu37.github.io/blog/cai-niao-de-nu-li-iosde-httpda-jian.html/"/>
    <updated>2015-10-09T19:27:16+08:00</updated>
    <id>http://zhyu37.github.io/blog/cai-niao-de-nu-li-iosde-httpda-jian</id>
    <content type="html"><![CDATA[<p>写接口  当然要用AFNetWorking</p>

<ol>
<li><p> 既然想通过HTTP 连接服务器</p>

<p> 需要写一个HTTPClient的文件  用来写发送get请求 和 发送post请求</p></li>
<li><p>(AFHTTPRequestOperation <em>)sendGetRequestWithPathString:(NSString </em>)pathString</p>

<p>  //在数据传输 之前 要进行暗号的 核对
      tokened:(BOOL)tokened
      //想要传给服务器的数据</p>

<p>  params:(id)params
      //当传输 成功之后 执行的</p>

<p>   success:(TDCHTTPRequestSuccessBlock)success
      //当传输  失败之后  执行的
       failure:(TDCHTTPRequestFailureBlock)failure;</p></li>
<li>(AFHTTPRequestOperation <em>)sendPostRequestWithPathString:(NSString </em>)pathString
       tokened:(BOOL)tokened
       params:(id)params
       paramType:(JHHTTPParamType)paramType
       success:(TDCHTTPRequestSuccessBlock)success
       failure:(TDCHTTPRequestFailureBlock)failure;</li>
</ol>


<p>用到一个  JHHTTPClient   第三方的HTTPClient
网盘链接   <a href="http://pan.baidu.com/s/1c0qcnD2">http://pan.baidu.com/s/1c0qcnD2</a></p>

<p>HTTPClient.m 
+ (AFHTTPRequestOperation <em>)sendGetRequestWithPathString:(NSString </em>)pathString tokened:(BOOL)tokened params:(id)params success:(TDCHTTPRequestSuccessBlock)success failure:(TDCHTTPRequestFailureBlock)failure
    {</p>

<p>//#define kHTTPServer  (@&ldquo;<a href="http://183.221.242.75:8089/APPInterface/">http://183.221.242.75:8089/APPInterface/</a>&rdquo;)</p>

<p>return [JHHTTPClient sendBaseRequestWithBaseString:kHTTPServer
    //pathString =  @&ldquo;user/Login.ashx?act=add_phone”;接口链接</p>

<p>   pathString:pathString
    //方法类型   Get Post  Put  Delete</p>

<p>methodType:JHHTTPMethodTypeGet
    //参数类型  Default Path KeyValue JSON XML</p>

<p>  paramType:JHHTTPParamTypeDefault
    //NSDictionary *params = @{@&ldquo;phone&rdquo;: phone};  传递 接口所需要 的参数</p>

<p>   params:params                                          files:nil                                            headers:nil
                                           success:^(AFHTTPRequestOperation *operation, id response) {
    //这个 类是用来 保存 服务器 发送回来 除了数据 之外的 信息
    //{&ldquo;Data&rdquo;:333409,&ldquo;code&rdquo;:0,&ldquo;Msg&rdquo;:&ldquo;&rdquo;,&ldquo;num&rdquo;:0}
    //Data  为数据  Status 为</p>

<p>   TDCModel *model = [TDCModel objectWithKeyValues:response];
    //#define kHTTPSuccess (200) </p>

<p>   if(kHTTPSuccess != model.code) {
                                                       if (failure) {</p>

<p>//
   failure(operation, [TDCError errorWithCode:model.code description:model.message]);</p>

<p>   }</p>

<p>   }else {
    if (success) {</p>

<p>//#define kHTTPData (@&ldquo;Data&rdquo;)
                                                     success(operation, [response objectForKey:kHTTPData]);</p>

<p>}
 }
}
                                            failure:failure progress:nil];
}</p>

<ul>
<li><p>(AFHTTPRequestOperation <em>)sendPostRequestWithPathString:(NSString </em>)pathString tokened:(BOOL)tokened params:(id)params paramType:(JHHTTPParamType)paramType success:(TDCHTTPRequestSuccessBlock)success failure:(TDCHTTPRequestFailureBlock)failure
  {</p>

<p>  return [JHHTTPClient sendBaseRequestWithBaseString:kHTTPServer
                                   pathString:pathString
                            methodType:JHHTTPMethodTypePost
paramType:paramType
 params:params
  files:nil
 headers:nil
                                           success:^(AFHTTPRequestOperation <em>operation, id response) {
TDCModel </em>model = [TDCModel objectWithKeyValues:response];</p></li>
</ul>


<p> if (model.code == 1 || model.code == 0) {</p>

<p> if (success) {
                                            success(operation, [response objectForKey:kHTTPData]);</p>

<p> }</p>

<p>  }else {</p>

<p>  if (failure) {
 if ([model.message isEqualToString:@&ldquo;&rdquo;])
{
                                                    failure(operation, [TDCError errorWithCode:model.code description:@&ldquo;服务器内部错误&rdquo;]);</p>

<p>}
                                                       else
{
                                                            failure(operation, [TDCError errorWithCode:model.code description:model.message]);
 }
}
}
}
                                          failure:^(AFHTTPRequestOperation <em>operation, NSError </em>error) {
if (3840 == error.code) {
error = [TDCError errorWithCode:TDCErrorCodeServerInvalid description:kStringServerException];
}
if (failure) {
                                            failure(operation, error);
}
} progress:nil];</p>

<p>}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://zhyu37.github.io/blog/hello-world.html/"/>
    <updated>2015-10-09T15:29:56+08:00</updated>
    <id>http://zhyu37.github.io/blog/hello-world</id>
    <content type="html"><![CDATA[<p>Today, I finally had my blog, I want to say &ldquo;hello world&rdquo;.</p>
]]></content>
  </entry>
  
</feed>
