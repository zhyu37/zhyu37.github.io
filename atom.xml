<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[有所为，有所不为]]></title>
  <link href="http://zhyu37.github.io/atom.xml" rel="self"/>
  <link href="http://zhyu37.github.io/"/>
  <updated>2015-10-12T23:41:58+08:00</updated>
  <id>http://zhyu37.github.io/</id>
  <author>
    <name><![CDATA[张昊煜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSNotificationCenter小结]]></title>
    <link href="http://zhyu37.github.io/blog/nsnotificationcenterxiao-jie.html/"/>
    <updated>2015-10-12T23:41:11+08:00</updated>
    <id>http://zhyu37.github.io/blog/nsnotificationcenterxiao-jie</id>
    <content type="html"><![CDATA[<hr />

<h2>NSNotification 消息机制</h2>

<blockquote><p>最近在项目中发现这个NSNotification还是很好用的。那我就简单介绍一下步骤，先要注册对象，当有人post的时候调用注册的方法，当然不能忘记<code>remove</code>注册了的对象。</p></blockquote>

<p>注册对象</p>




<pre><code>
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@"test" object:nil];
}
</code></pre>




<p>当对象被post之后  会调用 写好的test方法</p>




<pre><code>
 [[NSNotificationCenter defaultCenter] postNotificationName:@"test" object:nil];
    });
</pre>


<p></code></p>

<p>删除对象</p>




<pre><code>
[[NSNotificationCenter defaultCenter] removeObserver:self name:@"test" object:nil];
</code></pre>


<p><code>注册和删除对象 一定要成对出现  ，当然也可以在dealloc里面 一起删除</code></p>

<pre><code>
- (void)dealloc{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [super dealloc];
}
</pre>


<p></code></p>

<p>在这个类的.h 文件中添加下面的的外部申明</p>




<pre><code>
extern NSString * const testNotification;
</pre>


<p></code></p>

<p>在.m中定义常量</p>




<pre><code>
NSString * const testNotification = @"BNRColorChanged";
</pre>


<p></code></p>

<p><code>如果安上面的申请方法 我们的注册 和 删除对象也可以改变一下</code></p>

<pre><code>

[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:testNotification object:nil];
}

post 删除 同理

</pre>


<p></code></p>

<h4>See You</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C 2.0--10.在既有类中使用关联对象存放自定义数据]]></title>
    <link href="http://zhyu37.github.io/blog/effective-objective-c-2-dot-0-10-dot-zai-ji-you-lei-zhong-shi-yong-guan-lian-dui-xiang-cun-fang-zi-ding-yi-shu-ju.html/"/>
    <updated>2015-10-10T00:47:52+08:00</updated>
    <id>http://zhyu37.github.io/blog/effective-objective-c-2-dot-0-10-dot-zai-ji-you-lei-zhong-shi-yong-guan-lian-dui-xiang-cun-fang-zi-ding-yi-shu-ju</id>
    <content type="html"><![CDATA[<p>当我们想在对象中存放其他信息时，一般会采用创建其子类后改用这个子类对象。然而并非所有情况都可以这么做。so Object-c中有一个强大的特性——关联对象(Associated Object)</p>

<p>关联策略</p>

<p>关联策略
等价属性
说明</p>

<p>OBJC_ASSOCIATION_ASSIGN
@property (assign) or @property (unsafe_unretained)
弱引用关联对象</p>

<p>OBJC_ASSOCIATION_RETAIN_NONATOMIC
@property (strong, nonatomic)
强引用关联对象，且为非原子操作</p>

<p>OBJC_ASSOCIATION_COPY_NONATOMIC
@property (copy, nonatomic)
复制关联对象，且为非原子操作</p>

<p>OBJC_ASSOCIATION_RETAIN
@property (strong, atomic)
强引用关联对象，且为原子操作</p>

<p>OBJC_ASSOCIATION_COPY
@property (copy, atomic)
复制关联对象，且为原子操作</p>

<p>其中，第 2
 种与第 4
 种、第 3
 种与第 5
 种关联策略的唯一差别就在于操作是否具有原子性。由于操作的原子性不在本文的讨论范围内，所以下面的实验和讨论就以前三种以例进行展开。</p>

<p>方法</p>

<p>//以给定的键和策略为某对象设置关联对象值
void objc setAssociatedObject(id object, const void *key, id value, objc AssociationPolicy policy);</p>

<p>//根据给给定的键从某对象中获取相应地关联对象值
 id objc getAssociatedObject(id object, const void *key);</p>

<p>//移除所指定对象的全部关联对象
void objc removeAssociatedObjects(id object);</p>

<p>key 值</p>

<p>关于前两个函数中的 key
 值是我们需要重点关注的一个点，这个 key 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 key
 值：</p>

<ol>
<li>声明 static char kAssociatedObjectKey;，使用 &amp;kAssociatedObjectKey 作为 key 值;</li>
<li>声明 static void *kAssociatedObjectKey = &kAssociatedObjectKey; ，使用 kAssociatedObjectKey 作为 key值；</li>
<li>用 selector，使用 getter方法的名称作为 key值</li>
</ol>


<p>我们把对象想象成NSDicitionary,把关联对象想象成字典的条目。存取关联对象的值就相当于NSDicitionary中调用[object setObject:value forKey:key]和[object setObjectForKey:key]。两者之间有个最重要的差别key(键) 是一个不透明的指针。所以通常使用静态全局变量做键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[菜鸟的努力-ios的HTTP搭建]]></title>
    <link href="http://zhyu37.github.io/blog/cai-niao-de-nu-li-iosde-httpda-jian.html/"/>
    <updated>2015-10-09T19:27:16+08:00</updated>
    <id>http://zhyu37.github.io/blog/cai-niao-de-nu-li-iosde-httpda-jian</id>
    <content type="html"><![CDATA[<p>写接口  当然要用AFNetWorking</p>

<ol>
<li><p> 既然想通过HTTP 连接服务器</p>

<p> 需要写一个HTTPClient的文件  用来写发送get请求 和 发送post请求</p></li>
<li><p>(AFHTTPRequestOperation <em>)sendGetRequestWithPathString:(NSString </em>)pathString</p>

<p>  //在数据传输 之前 要进行暗号的 核对
      tokened:(BOOL)tokened
      //想要传给服务器的数据</p>

<p>  params:(id)params
      //当传输 成功之后 执行的</p>

<p>   success:(TDCHTTPRequestSuccessBlock)success
      //当传输  失败之后  执行的
       failure:(TDCHTTPRequestFailureBlock)failure;</p></li>
<li>(AFHTTPRequestOperation <em>)sendPostRequestWithPathString:(NSString </em>)pathString
       tokened:(BOOL)tokened
       params:(id)params
       paramType:(JHHTTPParamType)paramType
       success:(TDCHTTPRequestSuccessBlock)success
       failure:(TDCHTTPRequestFailureBlock)failure;</li>
</ol>


<p>用到一个  JHHTTPClient   第三方的HTTPClient
网盘链接   <a href="http://pan.baidu.com/s/1c0qcnD2">http://pan.baidu.com/s/1c0qcnD2</a></p>

<p>HTTPClient.m 
+ (AFHTTPRequestOperation <em>)sendGetRequestWithPathString:(NSString </em>)pathString tokened:(BOOL)tokened params:(id)params success:(TDCHTTPRequestSuccessBlock)success failure:(TDCHTTPRequestFailureBlock)failure
    {</p>

<p>//#define kHTTPServer  (@&ldquo;<a href="http://183.221.242.75:8089/APPInterface/">http://183.221.242.75:8089/APPInterface/</a>&rdquo;)</p>

<p>return [JHHTTPClient sendBaseRequestWithBaseString:kHTTPServer
    //pathString =  @&ldquo;user/Login.ashx?act=add_phone”;接口链接</p>

<p>   pathString:pathString
    //方法类型   Get Post  Put  Delete</p>

<p>methodType:JHHTTPMethodTypeGet
    //参数类型  Default Path KeyValue JSON XML</p>

<p>  paramType:JHHTTPParamTypeDefault
    //NSDictionary *params = @{@&ldquo;phone&rdquo;: phone};  传递 接口所需要 的参数</p>

<p>   params:params                                          files:nil                                            headers:nil
                                           success:^(AFHTTPRequestOperation *operation, id response) {
    //这个 类是用来 保存 服务器 发送回来 除了数据 之外的 信息
    //{&ldquo;Data&rdquo;:333409,&ldquo;code&rdquo;:0,&ldquo;Msg&rdquo;:&ldquo;&rdquo;,&ldquo;num&rdquo;:0}
    //Data  为数据  Status 为</p>

<p>   TDCModel *model = [TDCModel objectWithKeyValues:response];
    //#define kHTTPSuccess (200) </p>

<p>   if(kHTTPSuccess != model.code) {
                                                       if (failure) {</p>

<p>//
   failure(operation, [TDCError errorWithCode:model.code description:model.message]);</p>

<p>   }</p>

<p>   }else {
    if (success) {</p>

<p>//#define kHTTPData (@&ldquo;Data&rdquo;)
                                                     success(operation, [response objectForKey:kHTTPData]);</p>

<p>}
 }
}
                                            failure:failure progress:nil];
}</p>

<ul>
<li><p>(AFHTTPRequestOperation <em>)sendPostRequestWithPathString:(NSString </em>)pathString tokened:(BOOL)tokened params:(id)params paramType:(JHHTTPParamType)paramType success:(TDCHTTPRequestSuccessBlock)success failure:(TDCHTTPRequestFailureBlock)failure
  {</p>

<p>  return [JHHTTPClient sendBaseRequestWithBaseString:kHTTPServer
                                   pathString:pathString
                            methodType:JHHTTPMethodTypePost
paramType:paramType
 params:params
  files:nil
 headers:nil
                                           success:^(AFHTTPRequestOperation <em>operation, id response) {
TDCModel </em>model = [TDCModel objectWithKeyValues:response];</p></li>
</ul>


<p> if (model.code == 1 || model.code == 0) {</p>

<p> if (success) {
                                            success(operation, [response objectForKey:kHTTPData]);</p>

<p> }</p>

<p>  }else {</p>

<p>  if (failure) {
 if ([model.message isEqualToString:@&ldquo;&rdquo;])
{
                                                    failure(operation, [TDCError errorWithCode:model.code description:@&ldquo;服务器内部错误&rdquo;]);</p>

<p>}
                                                       else
{
                                                            failure(operation, [TDCError errorWithCode:model.code description:model.message]);
 }
}
}
}
                                          failure:^(AFHTTPRequestOperation <em>operation, NSError </em>error) {
if (3840 == error.code) {
error = [TDCError errorWithCode:TDCErrorCodeServerInvalid description:kStringServerException];
}
if (failure) {
                                            failure(operation, error);
}
} progress:nil];</p>

<p>}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://zhyu37.github.io/blog/hello-world.html/"/>
    <updated>2015-10-09T15:29:56+08:00</updated>
    <id>http://zhyu37.github.io/blog/hello-world</id>
    <content type="html"><![CDATA[<p>Today, I finally had my blog, I want to say &ldquo;hello world&rdquo;.</p>
]]></content>
  </entry>
  
</feed>
