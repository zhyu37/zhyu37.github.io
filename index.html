
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>有所为，有所不为</title>
  <meta name="author" content="张昊煜">

  
  <meta name="description" content=" 错误：The operation couldn’t be completed 如果报这个错，大概是因为Bundle Identifier改动了。 只需要重置模拟器就好了 See You
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhyu37.github.io/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="有所为，有所不为" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">有所为，有所不为</a></h1>
  
    <h2>张昊煜</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
<ul class="subscription">
  <li><a href="https://pinboard.in/u:zhyu" rel="subscribe-pinboard" title="Pinboard Bookmarks" target="_blank">Pinboard</a></li>
</ul>
  
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="zhyu37.github.io" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/cuo-wu-the-operation-couldnt-be-completed.html/">错误: The Operation Couldn't Be Completed</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-14T00:55:41+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:55 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>错误：The operation couldn’t be completed</h2>

<blockquote><p>如果报这个错，大概是因为Bundle Identifier改动了。
<img src="../images/21_413993_f07e2ce972211fe.png" alt="Alt text" />
<code>只需要重置模拟器就好了</code>
<img src="../images/21_505254_c149977c77f5390.png" alt="Alt text" /></p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/iosjie-shou-boollei-xing-shu-ju-wen-ti.html/">iOS接收bool类型数据问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-08T20:33:20+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:33 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS接口获取BOOL问题</h2>

<blockquote><p>在iOS接受的数据中有Bool类型时会出现true、false识别不了的情况，需要转一下格式在识别，比如改成int格式。</p></blockquote>

<p>实例接收true数据</p>


<p><img src="../images/QQ20160308-0.png" alt="Alt text" /></p>

<blockquote><p>但是和false的数据都判断成YES所以需要转换一下。</p></blockquote>

<pre><code>
if ([[dict objectForKey:@"subjectStatus"] intValue] == 0) {
                termType = 3;
            }
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/xiu-gai-ge-ren-xin-xi-shi-hou-duo-zu-uitextfieldti-jiao.html/">修改个人信息时候多组UITextField提交数据</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-05T02:47:43+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:47 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>修改个人信息时候多组UITextField提交数据</h2>

<p><img src="../images/QQ20160305-0.png" alt="Alt text" /></p>

<blockquote><p>个人经历：在写个人信息修改的时候发现，如果使用UITableView动态添加Cell时，提交修改信息无法通过[self.tableView reloadData];刷新UITableView来获取跟新的数据，因为提交数据的接口也是在提交按钮的事件里面无法先刷新再提交So问题来了。</p></blockquote>

<p><p>通过浅拷贝来拷贝对应UITextField组件来获取数据
<pre><code>
//右上角的编辑/确定 按钮
-(void)rightBarBtnClick:(UIBarButtonItem *)sender
{</p>

<p>   if ([sender.title isEqualToString:@&ldquo;编辑&rdquo;]) {
        [sender setTitle:@&ldquo;确定&rdquo;];
        self.editing = YES;
        [self.tableView reloadData];
    } else {
        [sender setTitle:@&ldquo;编辑&rdquo;];
        self.editing = NO;</p>

<p>   //向服务器发送数据
   [APHTTPMine changePeopleWithid:[APGlobal sharedAPGlobal].user.userId email:[APGlobal sharedAPGlobal].user.email name:self.nameTextField.text phone:self.phoneTextField.text collegeId:[NSNumber numberWithInteger:self.collegeId] grade:self.gradeTextField.text major:self.majorTextField.text wechat:self.wechatTextField.text headImgUrl:self.headImgUrl success:^(AFHTTPRequestOperation <em>operation, id response) {
   //本地缓存必要数据
   [APGlobal sharedAPGlobal].user.name = self.nameTextField.text;
            [APGlobal sharedAPGlobal].user.school = self.school;
            [APGlobal sharedAPGlobal].user.grade = self.gradeTextField.text;
            [APGlobal sharedAPGlobal].user.major = self.majorTextField.text;
            [APGlobal sharedAPGlobal].user.phone = self.phoneTextField.text;
            [APGlobal sharedAPGlobal].user.weichat = self.wechatTextField.text;
            [APGlobal sharedAPGlobal].user.headImgUrl = self.headImgUrl;
            [APGlobal sharedAPGlobal].user.collegeId = [NSNumber numberWithInteger:self.collegeId];
            //更新数据 并刷新
            [self setupInitInformation];
            [self.tableView reloadData];
        } failure:^(AFHTTPRequestOperation </em>operation, NSError *error) {</p>

<p>   }];</p>

<p>  }</p>

<p>}</p>

<p>//初始化的时候会调用 更新数据的时候也会调用
-(void)setupInitInformation
{
    self.name = [APGlobal sharedAPGlobal].user.name;
    self.school = [APGlobal sharedAPGlobal].user.school;
    self.grade = [APGlobal sharedAPGlobal].user.grade;
    self.major = [APGlobal sharedAPGlobal].user.major;
    self.phone = [APGlobal sharedAPGlobal].user.phone;
    self.wechat = [APGlobal sharedAPGlobal].user.weichat;
    self.headImgUrl = [APGlobal sharedAPGlobal].user.headImgUrl;
    self.collegeId = [[APGlobal sharedAPGlobal].user.collegeId integerValue];
}</p>

<p>//#pragma mark - UITableViewDataSource</p>

<p>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 6;
}</p>

<p>-(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
    APMinePersonInformationTableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:[APMinePersonInformationTableViewCell cellIdentifier]];
    cell.cellPersonLabel.delegate = self;
    [cell setSelectionStyle:UITableViewCellSelectionStyleNone];
    cell.cellPersonLabel.enabled = NO;
    cell.cellPersonLabel.borderStyle = UITextBorderStyleNone;
    switch (indexPath.row) {
        case 0:
            if (self.editing) {//编辑状态
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeDefault;
                self.nameTextField = cell.cellPersonLabel;</p>

<p>  }else{//非编辑状态
                cell.cellInformationLabel.text = @&ldquo;姓名:&rdquo;;
                cell.cellPersonLabel.text = self.name;
            }
            break;
        case 1:
            if (self.editing) {
                cell.cellPersonLabel.text = self.school;
            }else{
                cell.cellInformationLabel.text = @&ldquo;学校:&rdquo;;
                cell.cellPersonLabel.text = self.school;
            }
            break;
        case 2:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeDefault;
                self.gradeTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;年级:&rdquo;;
                cell.cellPersonLabel.text = [NSString stringWithFormat:@&ldquo;%@&rdquo;,self.grade];
            }
            break;
        case 3:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeDefault;
                self.majorTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;专业:&rdquo;;
                cell.cellPersonLabel.text = [NSString stringWithFormat:@&ldquo;%@&rdquo;,self.major];
            }
            break;
        case 4:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypePhonePad;
                self.phoneTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;电话号码:&rdquo;;
                cell.cellPersonLabel.text = self.phone;
            }
            break;
        case 5:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeNumberPad;
                self.wechatTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;微信号:&rdquo;;
                cell.cellPersonLabel.text = [NSString stringWithFormat:@&ldquo;%@&rdquo;,self.wechat];
            }
            break;
        default:
            break;
    }</p>

<p>   return cell;
}</p>

<p></pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/iosshi-jian-chuo-zhuan-shi-jian.html/">iOS时间戳转时间</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-03T17:08:17+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>5:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h3>iOS时间戳转时间</h3>

<blockquote><p>IOS项目中会遇到时间转的问题，当从服务端传回时间到客户端，而这个时间确是时间戳，并且是13位，如果是普通的字符串比如“2015-09-24 19:00:000” 这样转化是比较简单，但是时间戳不是这样的，ios生成的时间戳是10位，所以说需要进行转换。以下有几种方式：</p></blockquote>

<p><p>第一种：
<pre><code>
NSString * timeStampString = @&ldquo;1423189125874&rdquo;;
    NSDate *date = [NSDate dateWithTimeIntervalSince1970:[timeStampString doubleValue] / 1000];
    NSLog(@&ldquo;%f&rdquo;, ([date timeIntervalSince1970] * 1000.0));
</pre></code></p>

<p><p>第二种：
<pre><code>
   NSString * timeStampString = @&ldquo;1423189125874&rdquo;;
   NSTimeInterval <em>interval=[[timeStampString substringToIndex:10] doubleValue];
   NSDate *date = [NSDate dateWithTimeIntervalSince1970:</em>interval];
   NSLog(@&ldquo;%@&rdquo;, date);</p>

<p>//格式化时间：</p>

<p>   NSString * timeStampString = @&ldquo;1423189125874&rdquo;;
   NSTimeInterval <em>interval=[timeStampString doubleValue] / 1000.0;
   NSDate *date = [NSDate dateWithTimeIntervalSince1970:</em>interval];
   NSDateFormatter *objDateformat = [[NSDateFormatter alloc] init];
   [objDateformat setDateFormat:@&ldquo;yyyy-MM-dd HH:mm:ss.SSS&rdquo;];
   NSLog(@&ldquo;%@&rdquo;, [objDateformat stringFromDate: date]);
</pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shou-shi-yu-hong-mo-1-dot-1.html/">手势与触摸1.1</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-25T08:10:59+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:10 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>1.1手势与触摸-触摸</h2>

<blockquote><p>用户触摸屏幕时，应用程序会寻找相关的对象来处理此操作。触摸事件将在视图之间传递，直到某个对象负责相应开始。
每个触摸操作信息都保存到UITouch对象中，而这样<code>一组</code>UITouch则放在UIEvent对象里传递。每个UIEvent对象都代表着一次触摸事件，其中包含<code>一个或多个</code>UITouch。具体取决于两个因素：1. 开发者是否开启了多点触摸。2. 实际触摸了几个点。应用程序会在视图类或者控制类里收到触摸事件，而这两种类都继承了UIResponder类。开发者可以自己决定在哪个类里面响应事件。但初学者都想试着在<code>在非响应者类里实现底层的手势控制</code>但可能会遇到很多麻烦。在视图类中有两个好处：1. 可以提升封装度。 2. 便于绘制。在控制类中也有不用把主要处理逻辑放在其他类中实现的好处。</p></blockquote>

<h4><p>触摸的生命周期</h4>

<pre>
UITouchPhaseBegan——用户一旦触摸即进入此阶段。
UITouchPhaseMoved——用户的手指在屏幕中移动。
UITouchPhaseStationary——自上一个事件发生之后，用户仍然在触摸着屏幕表面没有移动。
UITouchPhaseEnded——当用户手指从屏幕上移走时。
UITouchPhaseCancelled——如果IOS系统不再追踪某个触摸操作。`相关视图已经从视窗里移走`。（划出界面）
</pre>


<h4><p>UIResponder类中的触摸事件响应方法</h4>

<pre>
touchesBegan:withEvent——用户一旦触摸
touchesMoved:withEvent——用户的手指在屏幕中移动
touchesEnded:withEvent——当用户手指从屏幕上移走时
touchesCancelled:withEvent——如果IOS系统不再追踪某个触摸操作。
</pre>


<p><code>视图有个模式叫做exclusive touch，当把exclusiveTouch的属性设置为YES时这个视窗的其他视图就收不到触摸事件了。</code></p>

<p>To be continued</p>

<p>See You</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-chu-shi-hua.html/">iOS开发初始化</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T19:49:45+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>7:49 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发中new和alloc的区别</h2>

<p><p>
<code>概括的说alloc可以自定义init,new相当于采用默认的初始化</code></p>

<blockquote><ol>
<li>一般很少用到[className new],我们一般用到的都是[[className alloc] init].但是不代表没用用的。</li>
<li>这两个的区别是[className new]基本等同于[[className alloc] init]；区别只在于alloc分配内存的时候使用了zone.
<code>这个zone是个什么东东呢？</code>
它是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度；
下面是源代码
<pre><code>
+new
{
id newObject = (<em>_alloc)((Class)self, 0);
Class metaClass = self->isa;
if (class_getVersion(metaClass) > 1)
return [newObject init];
else
return newObject;
}
//而 alloc/init 像这样：
+alloc
{
return (</em>_zoneAlloc)((Class)self, 0, malloc_default_zone());<br/>
}
-init
{
return self;
}
</pre></code></li>
<li>为什么不推荐使用new呢？
<p>因为如果使用new的话就只能采用默认的Init了，显然显示初始化比隐藏初始化好。两者没有什么太大的区别。</li>
</ol>
</blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-zhi-shen-kao-bei-,-qian-kao-bei.html/">iOS开发之深拷贝、浅拷贝</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T17:01:32+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:01 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发之深拷贝与浅拷贝</h2>

<p><p>
<code>如有错误请大家多多指教，请大家多关注 https://github.com/zhyu37</code></p>

<blockquote><p>对象拷贝分为两种方式：浅拷贝和深拷贝，其实就是copy和retain的区别。copy是创建一个新对象，而retain是创建一个指针，引用计数加1.<code>copy属性</code>表示两个对象内容相同，新对象的retain引用计数为1，和旧的对象毫无关系了。<code>retain属性</code>仅仅是复制了旧对象的指针，内容相同，但是retain引用计数为2.总体来说就是浅拷贝就是指针的复制，深拷贝是真正的创建了新对象。</p>

<h4>非集合对象的copy与mutableCopy方法</h4>

<p><p>这里指的是NSString,NSNumber等等一类的对象。
<pre><code>
NSString <em>string = @&ldquo;origin&rdquo;;
NSString </em>stringCopy = [string copy];
NSMutableString <em>stringMCopy = [string mutableCopy];
//可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；
</pre></code>
<p>再看下面的例子
<pre><code>
NSMutableString </em>string = [NSMutableString stringWithString: @&ldquo;origion&rdquo;];
NSString <em>stringCopy = [string copy];
NSMutableString </em>mStringCopy = [string copy];
NSMutableString *stringMCopy = [string mutableCopy];[mStringCopy appendString:@&ldquo;mm&rdquo;];//error
[string appendString:@&ldquo; origion!&rdquo;];
[stringMCopy appendString:@&ldquo;!!&rdquo;];
//以上四个NSString对象所分配的内存都是不一样的。但是对于mStringCopy其实是个imutable对象，所以上述会报错。
对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。
</pre></code></p></blockquote>

<p><p></p>

<h4>集合对象的深拷贝和浅拷贝</h4>

<p>指NSArray，NSDictionary等。对于容器类本身，上面讨论的结论也是适用的，需要探讨的是复制后容器内对象的变化。
<p>
<pre><code>
 //copy返回不可变对象，mutablecopy返回可变对象
 NSArray <em>array1 = [NSArray arrayWithObjects:@&ldquo;a&rdquo;,@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
 NSArray </em>arrayCopy1 = [array1 copy];
 //arrayCopy1是和array同一个NSArray对象（指向相同的对象），包括array里面的元素也是指向相同的指针
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[array1 retainCount]);
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[arrayCopy1 retainCount]);
 NSMutableArray <em>mArrayCopy1 = [array1 mutableCopy];
 //mArrayCopy1是array1的可变副本，指向的对象和array1不同，但是其中的元素和array1中的元素指向的是同一个对象。mArrayCopy1还可以修改自己的对象
[mArrayCopy1 addObject:@&ldquo;de&rdquo;];
[mArrayCopy1 removeObjectAtIndex:0];
//array1和arrayCopy1是指针复制，而mArrayCopy1是对象复制，mArrayCopy1还可以改变期内的元素：删除或添加。但是注意的是，容器内的元素内容都是指针复制。
</pre></code>
<p>下一个例子
<pre><code>
NSArray </em>mArray1 = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;a&rdquo;],@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
NSArray <em>mArrayCopy2 = [mArray1 copy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
NSMutableArray </em>mArrayMCopy1 = [mArray1 mutableCopy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
//mArrayCopy2,mArrayMCopy1和mArray1指向的都是不一样的对象，但是其中的元素都是一样的对象——同一个指针
//一下做测试
NSMutableString <em>testString = [mArray1 objectAtIndex:0];
//testString = @&ldquo;1a1&rdquo;;
//这样会改变testString的指针，其实是将@“1a1”临时对象赋给了testString
[testString appendString:@&ldquo; tail&rdquo;];
//这样以上三个数组的首元素都被改变了
//由此可见，对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝。
</pre></code>
<p>深拷贝
<pre><code>
NSArray </em>array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;first&rdquo;],[NSStringstringWithString:@&ldquo;b&rdquo;],@&ldquo;c&rdquo;,nil];
NSArray <em>deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];
NSArray</em> trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:
[NSKeyedArchiver archivedDataWithRootObject: array]];
//trueDeepCopyArray是完全意义上的深拷贝，而deepCopyArray则不是，对于deepCopyArray内的不可变元素其还是指针复制。或者我们自己实现深拷贝的方法。因为如果容器的某一元素是不可变的，那你复制完后该对象仍旧是不能改变的，因此只需要指针复制即可。除非你对容器内的元素重新赋值，否则指针复制即已足够。
</pre></code></p>

<h4>自定义对象</h4>

<p>如果是我们定义的对象，那么我们自己要实现NSCopying,NSMutableCopying这样就能调用copy和mutablecopy了。
<pre><code>
@interface MyObj : NSObject&lt;NSCopying,NSMutableCopying>
{
         NSMutableString <em>name;
         NSString </em>imutableStr;
         int age;
}
@property (nonatomic, retain) NSMutableString <em>name;
@property (nonatomic, retain) NSString </em>imutableStr;
@property (nonatomic) int age;
@end
@implementation MyObj
@synthesize name;
@synthesize age;
@synthesize imutableStr;
- (id)init
{
         if (self = [super init])
         {
                   self.name = [[NSMutableString alloc]init];
                   self.imutableStr = [[NSString alloc]init];
                   age = -1;
         }
         return self;
}
- (void)dealloc
{
         [name release];
         [imutableStr release];
         [super dealloc];
}
- (id)copyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = [[[self class] allocWithZone:zone] init];
         copy->name = [name copy];
         copy->imutableStr = [imutableStr copy];
//       copy->name = [name copyWithZone:zone];;
//       copy->imutableStr = [name copyWithZone:zone];//
         copy->age = age;
         return copy;
}
- (id)mutableCopyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = NSCopyObject(self, 0, zone);
         copy->name = [self.name mutableCopy];
         copy->age = age;
         return copy;
}
</pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shi-xian-descriptionfang-fa.html/">实现description方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-25T16:05:11+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:05 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>实现description方法</h2>

<blockquote><p>当想打印对象的信息时，对象会收到description消息，该方法返回的描述信息回取代“格式字符串”里的“%@”。</p></blockquote>

<p><p>
<pre><code>
NSArray *object = @[@&ldquo;a string, @(123)&rdquo;];
NSLog(@&ldquo;object = %@&rdquo;,object);</p>

<p>//如果是打印 会输出
object = (
    &ldquo;a string&rdquo;,
    123
)</p>

<p>//如果在自定义的类上这么做  则会打印
object = &lt;EOCPerson: 0x7fd9a1660600></p>

<p></pre></code></p>

<blockquote><p>但是 这样的打印 如果不需要 类名 和 地址的话 ，这个打印毫无意义。so 我们需要复写 description方法。</p></blockquote>

<p><pre><code>
EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&ldquo;Bob&rdquo; lastName:@&ldquo;Smith&rdquo;];
NSLog(@&ldquo;person = %@&rdquo;, person);</p>

<p>该类的description方法通常是这样实现的
-(NSString*) description{
    return [NSStringstringWithFormat:@&ldquo;&lt;%@: %p, \&rdquo;%@ %@\&ldquo;>&rdquo;,[self class], self, <em>firstName, </em>lastName];
}</p>

<p>//打印结果
person = &lt;EOCPerson: 0x7fd9a1660600, &ldquo;Bob Smith&rdquo;>
</pre></code></p>

<blockquote><p><code>作者建议:</code>在新实现的description方法中，也应该像默认的实现那样，打印出类的名字和指针地址，因为这些内容有时也会用到。NSArray类的对象就没有打印这两项内容，显然没有固定规律可循。<code>用NSDicionary来实现此功能可以使代码更以维护.</code></p></blockquote>

<p><p>debugDescription</p>

<blockquote><p>此方法的用意与description非常相似。区别在于前者是开发者在调试器中以控制台命令打印对象时才调用的。用法和description类似.</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/li-jie-lei-dui-xiang-de-yong-yi.html/">查询类的类型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-10T09:20:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:20 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十四条 理解“类对象”的用意</h2>

<blockquote><p>每个实例都用一个指向Class对象的指针，用来表示其类型。如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</p></blockquote>

<pre><code>
NSMutableDictionary *dict = [NSMutableDictionary new];
//判断对象是否是否个特定类的实例
[dict isMemberofClass:[NSDictionary class]];//NO
[dict isMemberofClass:[NSMutableDictionary class]];//Yes
//判断对象是否为某个类或其派生类的实例
[dict isKindofClass:[NSDictionary class]];//Yes
[dict isKindofClass:[NSArray class]];//No
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/method-swizzling.html/">Method Swizzling</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-09T13:08:45+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十三条  用“方法调配技术”调试“黑盒方法”</h2>

<blockquote><p>在没有一个类的源码时，例如调用别人API时。想改变其中一个方法的实现，除了继承重写、借助重类名方法之外，现在还发现了一种新的方法——Method Swizzling。</p></blockquote>

<p>一个NSString类的例子</p>


<pre><code>
//头文件 
#import  <objc/runtime.h>

//具体实现
 //1.测试字符串
    NSString *str = @"Hello World";
    
//2.打印正常方法调用的值
    NSLog(@"%@ %@",[str lowercaseString],[str uppercaseString]);
    
Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
    Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));
    method_exchangeImplementations(originalMethod, swappedMethod);
    
 //4.打印方法调配后的值
    NSLog(@"%@ %@",[str lowercaseString],[str uppercaseString]);
</pre>


<p></code></p>

<p><p>打印结果
<pre><code>
2015-11-09 12:49:23.361 ChangeMethods[810:459887] hello world HELLO WORLD
2015-11-09 12:49:23.362 ChangeMethods[810:459887] HELLO WORLD hello world
</pre></code></p>

<blockquote><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。
每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，
我们可以利用 class_replaceMethod 来修改类，
我们可以利用 method_setImplementation 来直接设置某个方法的IMP</p>

<h2>See You</h2></blockquote>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 张昊煜 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
