
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>有所为，有所不为</title>
  <meta name="author" content="张昊煜">

  
  <meta name="description" content="1.1手势与触摸-触摸 用户触摸屏幕时，应用程序会寻找相关的对象来处理此操作。触摸事件将在视图之间传递，直到某个对象负责相应开始。
每个触摸操作信息都保存到UITouch对象中，而这样一组UITouch则放在UIEvent对象里传递。每个UIEvent对象都代表着一次触摸事件， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhyu37.github.io/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="有所为，有所不为" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">有所为，有所不为</a></h1>
  
    <h2>张昊煜</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="zhyu37.github.io" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shou-shi-yu-hong-mo-1-dot-1.html/">手势与触摸1.1</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-25T08:10:59+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:10 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>1.1手势与触摸-触摸</h2>

<blockquote><p>用户触摸屏幕时，应用程序会寻找相关的对象来处理此操作。触摸事件将在视图之间传递，直到某个对象负责相应开始。
每个触摸操作信息都保存到UITouch对象中，而这样<code>一组</code>UITouch则放在UIEvent对象里传递。每个UIEvent对象都代表着一次触摸事件，其中包含<code>一个或多个</code>UITouch。具体取决于两个因素：1. 开发者是否开启了多点触摸。2. 实际触摸了几个点。应用程序会在视图类或者控制类里收到触摸事件，而这两种类都继承了UIResponder类。开发者可以自己决定在哪个类里面响应事件。但初学者都想试着在<code>在非响应者类里实现底层的手势控制</code>但可能会遇到很多麻烦。在视图类中有两个好处：1. 可以提升封装度。 2. 便于绘制。在控制类中也有不用把主要处理逻辑放在其他类中实现的好处。</p></blockquote>

<h4><p>触摸的生命周期</h4>

<pre>
UITouchPhaseBegan——用户一旦触摸即进入此阶段。
UITouchPhaseMoved——用户的手指在屏幕中移动。
UITouchPhaseStationary——自上一个事件发生之后，用户仍然在触摸着屏幕表面没有移动。
UITouchPhaseEnded——当用户手指从屏幕上移走时。
UITouchPhaseCancelled——如果IOS系统不再追踪某个触摸操作。`相关视图已经从视窗里移走`。（划出界面）
</pre>


<h4><p>UIResponder类中的触摸事件响应方法</h4>

<pre>
touchesBegan:withEvent——用户一旦触摸
touchesMoved:withEvent——用户的手指在屏幕中移动
touchesEnded:withEvent——当用户手指从屏幕上移走时
touchesCancelled:withEvent——如果IOS系统不再追踪某个触摸操作。
</pre>


<p><code>视图有个模式叫做exclusive touch，当把exclusiveTouch的属性设置为YES时这个视窗的其他视图就收不到触摸事件了。</code></p>

<p>To be continued</p>

<p>See You</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-chu-shi-hua.html/">iOS开发初始化</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T19:49:45+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>7:49 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发中new和alloc的区别</h2>

<p><p>
<code>概括的说alloc可以自定义init,new相当于采用默认的初始化</code></p>

<blockquote><ol>
<li>一般很少用到[className new],我们一般用到的都是[[className alloc] init].但是不代表没用用的。</li>
<li>这两个的区别是[className new]基本等同于[[className alloc] init]；区别只在于alloc分配内存的时候使用了zone.
<code>这个zone是个什么东东呢？</code>
它是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度；
下面是源代码
<pre><code>
+new
{
id newObject = (<em>_alloc)((Class)self, 0);
Class metaClass = self->isa;
if (class_getVersion(metaClass) > 1)
return [newObject init];
else
return newObject;
}
//而 alloc/init 像这样：
+alloc
{
return (</em>_zoneAlloc)((Class)self, 0, malloc_default_zone());<br/>
}
-init
{
return self;
}
</pre></code></li>
<li>为什么不推荐使用new呢？
<p>因为如果使用new的话就只能采用默认的Init了，显然显示初始化比隐藏初始化好。两者没有什么太大的区别。</li>
</ol>
</blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-zhi-shen-kao-bei-,-qian-kao-bei.html/">iOS开发之深拷贝、浅拷贝</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T17:01:32+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:01 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发之深拷贝与浅拷贝</h2>

<p><p>
<code>如有错误请大家多多指教，请大家多关注 https://github.com/zhyu37</code></p>

<blockquote><p>对象拷贝分为两种方式：浅拷贝和深拷贝，其实就是copy和retain的区别。copy是创建一个新对象，而retain是创建一个指针，引用计数加1.<code>copy属性</code>表示两个对象内容相同，新对象的retain引用计数为1，和旧的对象毫无关系了。<code>retain属性</code>仅仅是复制了旧对象的指针，内容相同，但是retain引用计数为2.总体来说就是浅拷贝就是指针的复制，深拷贝是真正的创建了新对象。</p>

<h4>非集合对象的copy与mutableCopy方法</h4>

<p><p>这里指的是NSString,NSNumber等等一类的对象。
<pre><code>
NSString <em>string = @&ldquo;origin&rdquo;;
NSString </em>stringCopy = [string copy];
NSMutableString <em>stringMCopy = [string mutableCopy];
//可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；
</pre></code>
<p>再看下面的例子
<pre><code>
NSMutableString </em>string = [NSMutableString stringWithString: @&ldquo;origion&rdquo;];
NSString <em>stringCopy = [string copy];
NSMutableString </em>mStringCopy = [string copy];
NSMutableString *stringMCopy = [string mutableCopy];[mStringCopy appendString:@&ldquo;mm&rdquo;];//error
[string appendString:@&ldquo; origion!&rdquo;];
[stringMCopy appendString:@&ldquo;!!&rdquo;];
//以上四个NSString对象所分配的内存都是不一样的。但是对于mStringCopy其实是个imutable对象，所以上述会报错。
对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。
</pre></code></p></blockquote>

<p><p></p>

<h4>集合对象的深拷贝和浅拷贝</h4>

<p>指NSArray，NSDictionary等。对于容器类本身，上面讨论的结论也是适用的，需要探讨的是复制后容器内对象的变化。
<p>
<pre><code>
 //copy返回不可变对象，mutablecopy返回可变对象
 NSArray <em>array1 = [NSArray arrayWithObjects:@&ldquo;a&rdquo;,@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
 NSArray </em>arrayCopy1 = [array1 copy];
 //arrayCopy1是和array同一个NSArray对象（指向相同的对象），包括array里面的元素也是指向相同的指针
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[array1 retainCount]);
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[arrayCopy1 retainCount]);
 NSMutableArray <em>mArrayCopy1 = [array1 mutableCopy];
 //mArrayCopy1是array1的可变副本，指向的对象和array1不同，但是其中的元素和array1中的元素指向的是同一个对象。mArrayCopy1还可以修改自己的对象
[mArrayCopy1 addObject:@&ldquo;de&rdquo;];
[mArrayCopy1 removeObjectAtIndex:0];
//array1和arrayCopy1是指针复制，而mArrayCopy1是对象复制，mArrayCopy1还可以改变期内的元素：删除或添加。但是注意的是，容器内的元素内容都是指针复制。
</pre></code>
<p>下一个例子
<pre><code>
NSArray </em>mArray1 = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;a&rdquo;],@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
NSArray <em>mArrayCopy2 = [mArray1 copy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
NSMutableArray </em>mArrayMCopy1 = [mArray1 mutableCopy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
//mArrayCopy2,mArrayMCopy1和mArray1指向的都是不一样的对象，但是其中的元素都是一样的对象——同一个指针
//一下做测试
NSMutableString <em>testString = [mArray1 objectAtIndex:0];
//testString = @&ldquo;1a1&rdquo;;
//这样会改变testString的指针，其实是将@“1a1”临时对象赋给了testString
[testString appendString:@&ldquo; tail&rdquo;];
//这样以上三个数组的首元素都被改变了
//由此可见，对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝。
</pre></code>
<p>深拷贝
<pre><code>
NSArray </em>array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;first&rdquo;],[NSStringstringWithString:@&ldquo;b&rdquo;],@&ldquo;c&rdquo;,nil];
NSArray <em>deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];
NSArray</em> trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:
[NSKeyedArchiver archivedDataWithRootObject: array]];
//trueDeepCopyArray是完全意义上的深拷贝，而deepCopyArray则不是，对于deepCopyArray内的不可变元素其还是指针复制。或者我们自己实现深拷贝的方法。因为如果容器的某一元素是不可变的，那你复制完后该对象仍旧是不能改变的，因此只需要指针复制即可。除非你对容器内的元素重新赋值，否则指针复制即已足够。
</pre></code></p>

<h4>自定义对象</h4>

<p>如果是我们定义的对象，那么我们自己要实现NSCopying,NSMutableCopying这样就能调用copy和mutablecopy了。
<pre><code>
@interface MyObj : NSObject&lt;NSCopying,NSMutableCopying>
{
         NSMutableString <em>name;
         NSString </em>imutableStr;
         int age;
}
@property (nonatomic, retain) NSMutableString <em>name;
@property (nonatomic, retain) NSString </em>imutableStr;
@property (nonatomic) int age;
@end
@implementation MyObj
@synthesize name;
@synthesize age;
@synthesize imutableStr;
- (id)init
{
         if (self = [super init])
         {
                   self.name = [[NSMutableString alloc]init];
                   self.imutableStr = [[NSString alloc]init];
                   age = -1;
         }
         return self;
}
- (void)dealloc
{
         [name release];
         [imutableStr release];
         [super dealloc];
}
- (id)copyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = [[[self class] allocWithZone:zone] init];
         copy->name = [name copy];
         copy->imutableStr = [imutableStr copy];
//       copy->name = [name copyWithZone:zone];;
//       copy->imutableStr = [name copyWithZone:zone];//
         copy->age = age;
         return copy;
}
- (id)mutableCopyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = NSCopyObject(self, 0, zone);
         copy->name = [self.name mutableCopy];
         copy->age = age;
         return copy;
}
</pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shi-xian-descriptionfang-fa.html/">实现description方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-25T16:05:11+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:05 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>实现description方法</h2>

<blockquote><p>当想打印对象的信息时，对象会收到description消息，该方法返回的描述信息回取代“格式字符串”里的“%@”。</p></blockquote>

<p><p>
<pre><code>
NSArray *object = @[@&ldquo;a string, @(123)&rdquo;];
NSLog(@&ldquo;object = %@&rdquo;,object);</p>

<p>//如果是打印 会输出
object = (
    &ldquo;a string&rdquo;,
    123
)</p>

<p>//如果在自定义的类上这么做  则会打印
object = &lt;EOCPerson: 0x7fd9a1660600></p>

<p></pre></code></p>

<blockquote><p>但是 这样的打印 如果不需要 类名 和 地址的话 ，这个打印毫无意义。so 我们需要复写 description方法。</p></blockquote>

<p><pre><code>
EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&ldquo;Bob&rdquo; lastName:@&ldquo;Smith&rdquo;];
NSLog(@&ldquo;person = %@&rdquo;, person);</p>

<p>该类的description方法通常是这样实现的
-(NSString*) description{
    return [NSStringstringWithFormat:@&ldquo;&lt;%@: %p, \&rdquo;%@ %@\&ldquo;>&rdquo;,[self class], self, <em>firstName, </em>lastName];
}</p>

<p>//打印结果
person = &lt;EOCPerson: 0x7fd9a1660600, &ldquo;Bob Smith&rdquo;>
</pre></code></p>

<blockquote><p><code>作者建议:</code>在新实现的description方法中，也应该像默认的实现那样，打印出类的名字和指针地址，因为这些内容有时也会用到。NSArray类的对象就没有打印这两项内容，显然没有固定规律可循。<code>用NSDicionary来实现此功能可以使代码更以维护.</code></p></blockquote>

<p><p>debugDescription</p>

<blockquote><p>此方法的用意与description非常相似。区别在于前者是开发者在调试器中以控制台命令打印对象时才调用的。用法和description类似.</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/li-jie-lei-dui-xiang-de-yong-yi.html/">查询类的类型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-10T09:20:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:20 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十四条 理解“类对象”的用意</h2>

<blockquote><p>每个实例都用一个指向Class对象的指针，用来表示其类型。如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</p></blockquote>

<pre><code>
NSMutableDictionary *dict = [NSMutableDictionary new];
//判断对象是否是否个特定类的实例
[dict isMemberofClass:[NSDictionary class]];//NO
[dict isMemberofClass:[NSMutableDictionary class]];//Yes
//判断对象是否为某个类或其派生类的实例
[dict isKindofClass:[NSDictionary class]];//Yes
[dict isKindofClass:[NSArray class]];//No
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/method-swizzling.html/">Method Swizzling</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-09T13:08:45+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十三条  用“方法调配技术”调试“黑盒方法”</h2>

<blockquote><p>在没有一个类的源码时，例如调用别人API时。想改变其中一个方法的实现，除了继承重写、借助重类名方法之外，现在还发现了一种新的方法——Method Swizzling。</p></blockquote>

<p>一个NSString类的例子</p>


<pre><code>
//头文件 
#import  <objc/runtime.h>

//具体实现
 //1.测试字符串
    NSString *str = @"Hello World";
    
//2.打印正常方法调用的值
    NSLog(@"%@ %@",[str lowercaseString],[str uppercaseString]);
    
Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
    Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));
    method_exchangeImplementations(originalMethod, swappedMethod);
    
 //4.打印方法调配后的值
    NSLog(@"%@ %@",[str lowercaseString],[str uppercaseString]);
</pre>


<p></code></p>

<p><p>打印结果
<pre><code>
2015-11-09 12:49:23.361 ChangeMethods[810:459887] hello world HELLO WORLD
2015-11-09 12:49:23.362 ChangeMethods[810:459887] HELLO WORLD hello world
</pre></code></p>

<blockquote><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。
每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，
我们可以利用 class_replaceMethod 来修改类，
我们可以利用 method_setImplementation 来直接设置某个方法的IMP</p>

<h2>See You</h2></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/objc-msgsendde-zuo-yong.html/">objc_msgSend的作用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-01T21:51:47+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>9:51 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十一条  objc_msgSend的作用</h2>

<blockquote><p>objc_msgSend是obj-c中经常用到的一个功能，当你在对象上调用方法时就用用到这个——消息传递。</p></blockquote>

<pre><code>
id returnValue = [someObject messageName:parameter];
</pre>


<p></code>
<li>someObject 是对象
<li>messageName 为对象所属的方法
<li>parameter 为方法所需要的参数</p>

<p><code>messageName:parameter 叫选择子(selector)</code>   <br/>
<code>someObject  叫接收者(receiver)</code></p>

<blockquote><p>objc_msgSend的底层使用C写的，C的方法调用是<code>静态绑定(static bingding)</code>把方法硬编码到指令中，当需要时直接调用。C还可以使用<code>动态绑定(dynamic bingding)</code>在指令中只有一个函数调用指令，在运行期读取出来。objc是一门真正的动态语言.</p></blockquote>

<pre><code>
//objc 的底层会把id returnValue = [someObject messageName:parameter];转换成
id returnValue = objc_msgSend(someObject,
                                @selector(messageName),
                                parameter);
</pre>


<p></code></p>

<blockquote><p>在objc_msgSend中还用到了<code>尾调用优化</code>就是在结尾的时候调用另一个函数时，编译器是生成调转另一个函数的指令码，不会推入堆栈中。</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/textgame.html/">textGame</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-01T20:24:45+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>8:24 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>一个能看出你是否长大的测试</h2>

<p><img src="../images/2015image1.png" alt="Alt text" /></p>

<blockquote><p>一男人M要与未婚妻F相会结婚，但两人一河相隔，M必须要借船过河才能见到F，于是他开始四处找船。 这时见一个女子L刚好有船，M跟L借，L遇到M后爱上了他，就问：我爱上你了，你爱我吗？M比较诚实，说：对不起，我有未婚妻，我不能爱你。这么一来，L死活是不把船借给M，她的理由是：我爱你，你不爱我，这不公平，我不会借你的！M很沮丧，继续找船，刚好见一位叫S的女子，就向她借船，S说：我借给你没问题，但有个条件，我很喜欢你，你是不是喜欢我所谓，但你必须留下陪我一晚， 不然我不借你。M很为难，L不借他船，S如果再不借他的话就过不去河与F相见了，据说这个地方只有这两条船。为了彼岸的未婚妻，他不得不同意了S的要求， 与S有了NB。次日，S遵守承诺把船借给了M。 见到未婚妻F后，M一直心里有事，考虑了很久，终于决定把向L和S借船的故事跟F说了。可惜，F听了非常伤心，一气之下与M分了手，她觉得M不忠，不能原谅。F失恋了，很受打击。 这时他的生活里出现了位女子E，两人也开始恋爱了，但之前的故事一直让他耿耿于坏，E问M是不是有什么话要跟她说，于是，M一五一十地把他和L、S、F之间的故事讲了一遍。E听了后，说，我不会介意的，这些跟我没关系。
 <li>
  <li>
   <li>
   <li>
   <li>
   <li>
   <li>
   <li>
 <li>
   <li>
   <li>
    <li>
 <p>答案
<img src="../images/2015image2.png" alt="Alt text" /></p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ios-auto-layout.html/">Ios Auto Layout</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-25T20:27:46+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:27 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>Ios Auto Layout</h2>

<blockquote><p>一开始 学的时候frame的绝对位置确实比autLayout好用，但是随着iphone 的尺寸越来越多 就会发现在4寸屏上适配成功，发现到plus 上就不对了。so 我选择了autoLayout 因为他是相对布局 所以它更适合 尺寸的变换和 竖屏横屏的切换。但也不能说frame 没用处。</p></blockquote>

<p>autolayout的VFL(Visual Format Language)语法</p>




<pre><code>
NSString *vfl = @"V:|-5-[_view]-10-[_imageView(20)]-10-[_backBtn]-5-|";

//其实这段话就是说，在垂直方向从上到下，view离父视图5点，imageView距离view 10点，同时imageView是20点高，backBtn离imageView底部10点，距离父视图底部5点。
</pre>


<p></code></p>

<p>手动Constraint书写</p>


<pre><code>
[self.view addConstraint: [NSLayoutConstraint constraintWithItem:blueView
attribute:NSLayoutAttributeLeft
relatedBy:NSLayoutRelationEqual
toItem:redView
attribute:NSLayoutAttributeLeft
multiplier:1
constant:0]];
</pre>


<p></code></p>

<blockquote><p>通过上面的 讲解  发现AutoLayout还需要花费经历 再去学习一番。SO 我在github上发现了一位大神写的第三方的东西<code>Masonry</code>.<a href="https://github.com/SnapKit/Masonry">https://github.com/SnapKit/Masonry</a><br/>
开源项目Masonry旨在让自动布局（Auto Layout）的代码更简洁、可读性更强。</p>

<p>Masonry ，“一个轻量级的布局框架，采用更优雅的语法封装自动布局”，不需要使用XIB和Storyboard。它的创造者Jonas Budelmann 论证 了尽管自动布局很强大，但它很快就变得冗长而不可读。</p>

<p>Masonry是一种领域特定语言（DSL），为自动布局的所有功能提供便捷的方法，包括建立和修改约束、存取属性、设置优先级以及调试支持。</p></blockquote>

<p>view的x位于父视图中心，y距顶部5，width为10，hight为20。还是同样地意思 我用这种框架来写一下</p>


<pre><code>
[view mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.equalTo(self.mas_centerX);
        make.top.equalTo(self.mas_top).offset(5);
        make.width.equalTo(@(10));
        make.height.equalTo(@(20));
    }];
</pre>


<p></code></p>

<p>感觉还是很好用的</p>


<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/uipickerview.html/">UIPickerView</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-22T23:25:30+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>11:25 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>UIPickerView</h2>

<blockquote><p>UIPickerView是一个类似于选择器的东西。</p></blockquote>

<ul>
<li>UIPickerViewDelegate

<ul>
<li>//pikerView 的长度
(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component;</li>
<li>//pickerView 的宽度
(CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component;</li>
<li>//pickerView 里面的信息
(NSString <em>)pickerView:(UIPickerView </em>)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component;</li>
<li>//当被点击后执行
(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component;</li>
</ul>
</li>
<li>UIPickerViewDataSource

<ul>
<li>//pickerView 的个数
(NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView</li>
<li>//每个pickerView 的行数
(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component</li>
</ul>
</li>
</ul>


<p>pickerView初始化</p>


<pre><code>
@property (nonatomic, strong) UIPickerView *pickerView;


- (void)viewDidLoad {
// 显示选中框 default = NO
    self.pickerView.showsSelectionIndicator=YES;
    self.pickerView.dataSource = self;
    self.pickerView.delegate = self;
    [self.view addSubview:self.pickerView];
}


- (UIPickerView *)pickerView
{
    if (!_pickerView) {
        _pickerView = [[UIPickerView alloc] initWithFrame:CGRectMake(0, 0, 320, 480)];
    }
    return _pickerView;
}
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 张昊煜 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
