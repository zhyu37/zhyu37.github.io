
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>有所为，有所不为</title>
  <meta name="author" content="张昊煜">

  
  <meta name="description" content="友盟推送、分享问题合集 在第一次做友盟推送、分享的时候多多少少会有一些问题。这次项目又用到了决定做一个合集。请大家多多指教，有问题可以联系我466096851@qq.com。 1. 推送 Problem 1:在还没上架的时候只能申请到sandBox证书？http://blog.csdn.net/ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhyu37.github.io/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="有所为，有所不为" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">有所为，有所不为</a></h1>
  
    <h2>张昊煜</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
<ul class="subscription">
  <li><a href="https://pinboard.in/u:zhyu" rel="subscribe-pinboard" title="Pinboard Bookmarks" target="_blank">Pinboard</a></li>
</ul>
  
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="zhyu37.github.io" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/you-meng-fen-xiang-he-tui-song-wen-ti-he-ji.html/">友盟分享和推送问题合集</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-20T21:59:13+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:59 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>友盟推送、分享问题合集</h2>

<blockquote><p>在第一次做友盟推送、分享的时候多多少少会有一些问题。这次项目又用到了决定做一个合集。请大家多多指教，有问题可以联系我<code>466096851@qq.com</code>。</p></blockquote>

<p><p>1. 推送
<pre>
Problem 1:在还没上架的时候只能申请到sandBox证书？<a href="http://blog.csdn.net/gf771115/article/details/42492767">http://blog.csdn.net/gf771115/article/details/42492767</a>  这是证书的申请过程
Problem 2:添加SDK过程？<a href="http://bbs.umeng.com/thread-6191-1-1.html">http://bbs.umeng.com/thread-6191-1-1.html</a>  这个是AppDelegate.m 里面的写法。注意最好不要通过pod集合上去，因为有的SDK里面的东西会有重合了会报错。
Problem 3:推送的Alias:当需要绑定别名的时候，type 会有一些默认的类型比如kUMessageAliasTypeSina这样的，自定义的话随便写一个NSString就好了，一开始还以为在UMessage.h里面弄一个呢。。。。。。
</pre></p>

<p><p>2. 分享
<pre>
Problem 1：分享里面就属QQ的比较麻烦了？
首先没上架之前只能用一个sandBox的Key，然后就是在你的工程设置项,targets 一栏下,选中自己的 target,在 Info->URL Types 中添加 URL Schemes,它需要添加两个，设置Xcode的url scheme格式为“QQ”+腾讯QQ互联应用appId转换成十六进制（不足8位前面补0），例如“QQ05FC5B14”。 额外设置 url schemes 的格式为"tencent"+腾讯QQ互联应用appId,例如“tencent100424468”。
</pre></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/javaweb-di-%5B%3F%5D-tian.html/">JavaWeb 第一天</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-17T00:03:52+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:03 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>JavaWeb 第一天</h2>

<p><p>介绍struts2 框架
<pre>
1. 什么框架？框架有什么用
框架 是 实现部分功能的代码 （半成品），使用框架简化企业级软件开发，提高开发效率。
2. 什么是struts框架，有什么用？
struts2是Struts 的下一代产品，是在struts1和webwork的技术基础上进行了合并的全新框架。
Struts2以webwork为核心的。
Struts2 = Struts1 + webwork；
Struts2 是 Apache产品。
Struts2 是一个标准的MVC框架。 javaweb 中的model2模式就是一个MVC模式。 model2 = servlet+jsp+javabean。
Struts2 是在javaweb开发中使用的。
使用Struts2可以简化我们的web开发，并且降低程序的耦合度。
3. 类似于Struts2框架的产品
Struts1 webwork jsf springMVC
4. ssh = struts2 + spring + hibernate
5. ssi = springMVC + spring + ibatis
6. XWork 是webwork的核心
7. Xwork提供了很多核心功能：前端拦截机（interceptor），运行时表单属性验证，类型转换，强大的表达式语言（OGNL – the Object Graph Navigation Language），IoC（Inversion of Control反转控制）容器等
</pre></p>

<p><p>入门
<pre>
index.jsp->holleServlet->hello.jsp  web开发
index.jsp->helloeAction->hello.jsp struts2流程</p>

<p>struts目录
1. apps : 应用程序
2. doc : 文档
3. lib : struts2 框架所应用的jar以及插件包
4. src : 源代码(core Struts2的源代码;XWork-core 底层使用了xwork，xwork的源代码)</p>

<p>注意:
1. 导入jar包到开发工程 只需要导入 apps/struts2-blank.war 中所有jar包  &mdash;- 13 个jar包
2. 创建页面
3. 对Struts2框架进行配置
 web.xml 文件中配置前端控制器（核心控制器）&ndash;就是一个Filter  <code>是为了让struts2框架可以运行</code>
<code>
  <filter>      <filter-name>struts2</filter-name>      <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>  </filter>  <filter-mapping>     <filter-name>struts2</filter-name>      <url-pattern>/*</url-pattern>  </filter-mapping>
 </code>
  创建一个struts.xml配置文件，这个是Struts2框架配置文件 <code>目的是为了让框架运行</code>
  4. 创建一个类action
  5. index.jsp 添加链接</p>

<p>  <code>&lt;a href="${pageContext.request.contextPath}/hello.jsp"&gt;first&lt;/a&gt;</code>一定要加上.jsp
</pre></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/cuo-wu-the-operation-couldnt-be-completed.html/">错误: The Operation Couldn't Be Completed</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-14T00:55:41+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:55 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>错误：The operation couldn’t be completed</h2>

<blockquote><p>如果报这个错，大概是因为Bundle Identifier改动了。
<img src="../images/21_413993_f07e2ce972211fe.png" alt="Alt text" />
<code>只需要重置模拟器就好了</code>
<img src="../images/21_505254_c149977c77f5390.png" alt="Alt text" /></p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/iosjie-shou-boollei-xing-shu-ju-wen-ti.html/">iOS接收bool类型数据问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-08T20:33:20+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:33 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS接口获取BOOL问题</h2>

<blockquote><p>在iOS接受的数据中有Bool类型时会出现true、false识别不了的情况，需要转一下格式在识别，比如改成int格式。</p></blockquote>

<p>实例接收true数据</p>


<p><img src="../images/QQ20160308-0.png" alt="Alt text" /></p>

<blockquote><p>但是和false的数据都判断成YES所以需要转换一下。</p></blockquote>

<pre><code>
if ([[dict objectForKey:@"subjectStatus"] intValue] == 0) {
                termType = 3;
            }
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/xiu-gai-ge-ren-xin-xi-shi-hou-duo-zu-uitextfieldti-jiao.html/">修改个人信息时候多组UITextField提交数据</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-05T02:47:43+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:47 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>修改个人信息时候多组UITextField提交数据</h2>

<p><img src="../images/QQ20160305-0.png" alt="Alt text" /></p>

<blockquote><p>个人经历：在写个人信息修改的时候发现，如果使用UITableView动态添加Cell时，提交修改信息无法通过[self.tableView reloadData];刷新UITableView来获取跟新的数据，因为提交数据的接口也是在提交按钮的事件里面无法先刷新再提交So问题来了。</p></blockquote>

<p><p>通过浅拷贝来拷贝对应UITextField组件来获取数据
<pre><code>
//右上角的编辑/确定 按钮
-(void)rightBarBtnClick:(UIBarButtonItem *)sender
{</p>

<p>   if ([sender.title isEqualToString:@&ldquo;编辑&rdquo;]) {
        [sender setTitle:@&ldquo;确定&rdquo;];
        self.editing = YES;
        [self.tableView reloadData];
    } else {
        [sender setTitle:@&ldquo;编辑&rdquo;];
        self.editing = NO;</p>

<p>   //向服务器发送数据
   [APHTTPMine changePeopleWithid:[APGlobal sharedAPGlobal].user.userId email:[APGlobal sharedAPGlobal].user.email name:self.nameTextField.text phone:self.phoneTextField.text collegeId:[NSNumber numberWithInteger:self.collegeId] grade:self.gradeTextField.text major:self.majorTextField.text wechat:self.wechatTextField.text headImgUrl:self.headImgUrl success:^(AFHTTPRequestOperation <em>operation, id response) {
   //本地缓存必要数据
   [APGlobal sharedAPGlobal].user.name = self.nameTextField.text;
            [APGlobal sharedAPGlobal].user.school = self.school;
            [APGlobal sharedAPGlobal].user.grade = self.gradeTextField.text;
            [APGlobal sharedAPGlobal].user.major = self.majorTextField.text;
            [APGlobal sharedAPGlobal].user.phone = self.phoneTextField.text;
            [APGlobal sharedAPGlobal].user.weichat = self.wechatTextField.text;
            [APGlobal sharedAPGlobal].user.headImgUrl = self.headImgUrl;
            [APGlobal sharedAPGlobal].user.collegeId = [NSNumber numberWithInteger:self.collegeId];
            //更新数据 并刷新
            [self setupInitInformation];
            [self.tableView reloadData];
        } failure:^(AFHTTPRequestOperation </em>operation, NSError *error) {</p>

<p>   }];</p>

<p>  }</p>

<p>}</p>

<p>//初始化的时候会调用 更新数据的时候也会调用
-(void)setupInitInformation
{
    self.name = [APGlobal sharedAPGlobal].user.name;
    self.school = [APGlobal sharedAPGlobal].user.school;
    self.grade = [APGlobal sharedAPGlobal].user.grade;
    self.major = [APGlobal sharedAPGlobal].user.major;
    self.phone = [APGlobal sharedAPGlobal].user.phone;
    self.wechat = [APGlobal sharedAPGlobal].user.weichat;
    self.headImgUrl = [APGlobal sharedAPGlobal].user.headImgUrl;
    self.collegeId = [[APGlobal sharedAPGlobal].user.collegeId integerValue];
}</p>

<p>//#pragma mark - UITableViewDataSource</p>

<p>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 6;
}</p>

<p>-(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
    APMinePersonInformationTableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:[APMinePersonInformationTableViewCell cellIdentifier]];
    cell.cellPersonLabel.delegate = self;
    [cell setSelectionStyle:UITableViewCellSelectionStyleNone];
    cell.cellPersonLabel.enabled = NO;
    cell.cellPersonLabel.borderStyle = UITextBorderStyleNone;
    switch (indexPath.row) {
        case 0:
            if (self.editing) {//编辑状态
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeDefault;
                self.nameTextField = cell.cellPersonLabel;</p>

<p>  }else{//非编辑状态
                cell.cellInformationLabel.text = @&ldquo;姓名:&rdquo;;
                cell.cellPersonLabel.text = self.name;
            }
            break;
        case 1:
            if (self.editing) {
                cell.cellPersonLabel.text = self.school;
            }else{
                cell.cellInformationLabel.text = @&ldquo;学校:&rdquo;;
                cell.cellPersonLabel.text = self.school;
            }
            break;
        case 2:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeDefault;
                self.gradeTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;年级:&rdquo;;
                cell.cellPersonLabel.text = [NSString stringWithFormat:@&ldquo;%@&rdquo;,self.grade];
            }
            break;
        case 3:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeDefault;
                self.majorTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;专业:&rdquo;;
                cell.cellPersonLabel.text = [NSString stringWithFormat:@&ldquo;%@&rdquo;,self.major];
            }
            break;
        case 4:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypePhonePad;
                self.phoneTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;电话号码:&rdquo;;
                cell.cellPersonLabel.text = self.phone;
            }
            break;
        case 5:
            if (self.editing) {
                cell.cellPersonLabel.enabled = YES;
                cell.cellPersonLabel.borderStyle = UITextBorderStyleRoundedRect;
                cell.cellPersonLabel.keyboardType = UIKeyboardTypeNumberPad;
                self.wechatTextField = cell.cellPersonLabel;
            }else{
                cell.cellInformationLabel.text = @&ldquo;微信号:&rdquo;;
                cell.cellPersonLabel.text = [NSString stringWithFormat:@&ldquo;%@&rdquo;,self.wechat];
            }
            break;
        default:
            break;
    }</p>

<p>   return cell;
}</p>

<p></pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/iosshi-jian-chuo-zhuan-shi-jian.html/">iOS时间戳转时间</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-03T17:08:17+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>5:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h3>iOS时间戳转时间</h3>

<blockquote><p>IOS项目中会遇到时间转的问题，当从服务端传回时间到客户端，而这个时间确是时间戳，并且是13位，如果是普通的字符串比如“2015-09-24 19:00:000” 这样转化是比较简单，但是时间戳不是这样的，ios生成的时间戳是10位，所以说需要进行转换。以下有几种方式：</p></blockquote>

<p><p>第一种：
<pre><code>
NSString * timeStampString = @&ldquo;1423189125874&rdquo;;
    NSDate *date = [NSDate dateWithTimeIntervalSince1970:[timeStampString doubleValue] / 1000];
    NSLog(@&ldquo;%f&rdquo;, ([date timeIntervalSince1970] * 1000.0));
</pre></code></p>

<p><p>第二种：
<pre><code>
   NSString * timeStampString = @&ldquo;1423189125874&rdquo;;
   NSTimeInterval <em>interval=[[timeStampString substringToIndex:10] doubleValue];
   NSDate *date = [NSDate dateWithTimeIntervalSince1970:</em>interval];
   NSLog(@&ldquo;%@&rdquo;, date);</p>

<p>//格式化时间：</p>

<p>   NSString * timeStampString = @&ldquo;1423189125874&rdquo;;
   NSTimeInterval <em>interval=[timeStampString doubleValue] / 1000.0;
   NSDate *date = [NSDate dateWithTimeIntervalSince1970:</em>interval];
   NSDateFormatter *objDateformat = [[NSDateFormatter alloc] init];
   [objDateformat setDateFormat:@&ldquo;yyyy-MM-dd HH:mm:ss.SSS&rdquo;];
   NSLog(@&ldquo;%@&rdquo;, [objDateformat stringFromDate: date]);
</pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shou-shi-yu-hong-mo-1-dot-1.html/">手势与触摸1.1</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-25T08:10:59+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:10 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>1.1手势与触摸-触摸</h2>

<blockquote><p>用户触摸屏幕时，应用程序会寻找相关的对象来处理此操作。触摸事件将在视图之间传递，直到某个对象负责相应开始。
每个触摸操作信息都保存到UITouch对象中，而这样<code>一组</code>UITouch则放在UIEvent对象里传递。每个UIEvent对象都代表着一次触摸事件，其中包含<code>一个或多个</code>UITouch。具体取决于两个因素：1. 开发者是否开启了多点触摸。2. 实际触摸了几个点。应用程序会在视图类或者控制类里收到触摸事件，而这两种类都继承了UIResponder类。开发者可以自己决定在哪个类里面响应事件。但初学者都想试着在<code>在非响应者类里实现底层的手势控制</code>但可能会遇到很多麻烦。在视图类中有两个好处：1. 可以提升封装度。 2. 便于绘制。在控制类中也有不用把主要处理逻辑放在其他类中实现的好处。</p></blockquote>

<h4><p>触摸的生命周期</h4>

<pre>
UITouchPhaseBegan——用户一旦触摸即进入此阶段。
UITouchPhaseMoved——用户的手指在屏幕中移动。
UITouchPhaseStationary——自上一个事件发生之后，用户仍然在触摸着屏幕表面没有移动。
UITouchPhaseEnded——当用户手指从屏幕上移走时。
UITouchPhaseCancelled——如果IOS系统不再追踪某个触摸操作。`相关视图已经从视窗里移走`。（划出界面）
</pre>


<h4><p>UIResponder类中的触摸事件响应方法</h4>

<pre>
touchesBegan:withEvent——用户一旦触摸
touchesMoved:withEvent——用户的手指在屏幕中移动
touchesEnded:withEvent——当用户手指从屏幕上移走时
touchesCancelled:withEvent——如果IOS系统不再追踪某个触摸操作。
</pre>


<p><code>视图有个模式叫做exclusive touch，当把exclusiveTouch的属性设置为YES时这个视窗的其他视图就收不到触摸事件了。</code></p>

<p>To be continued</p>

<p>See You</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-chu-shi-hua.html/">iOS开发初始化</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T19:49:45+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>7:49 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发中new和alloc的区别</h2>

<p><p>
<code>概括的说alloc可以自定义init,new相当于采用默认的初始化</code></p>

<blockquote><ol>
<li>一般很少用到[className new],我们一般用到的都是[[className alloc] init].但是不代表没用用的。</li>
<li>这两个的区别是[className new]基本等同于[[className alloc] init]；区别只在于alloc分配内存的时候使用了zone.
<code>这个zone是个什么东东呢？</code>
它是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度；
下面是源代码
<pre><code>
+new
{
id newObject = (<em>_alloc)((Class)self, 0);
Class metaClass = self->isa;
if (class_getVersion(metaClass) > 1)
return [newObject init];
else
return newObject;
}
//而 alloc/init 像这样：
+alloc
{
return (</em>_zoneAlloc)((Class)self, 0, malloc_default_zone());<br/>
}
-init
{
return self;
}
</pre></code></li>
<li>为什么不推荐使用new呢？
<p>因为如果使用new的话就只能采用默认的Init了，显然显示初始化比隐藏初始化好。两者没有什么太大的区别。</li>
</ol>
</blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-zhi-shen-kao-bei-,-qian-kao-bei.html/">iOS开发之深拷贝、浅拷贝</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T17:01:32+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:01 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发之深拷贝与浅拷贝</h2>

<p><p>
<code>如有错误请大家多多指教，请大家多关注 https://github.com/zhyu37</code></p>

<blockquote><p>对象拷贝分为两种方式：浅拷贝和深拷贝，其实就是copy和retain的区别。copy是创建一个新对象，而retain是创建一个指针，引用计数加1.<code>copy属性</code>表示两个对象内容相同，新对象的retain引用计数为1，和旧的对象毫无关系了。<code>retain属性</code>仅仅是复制了旧对象的指针，内容相同，但是retain引用计数为2.总体来说就是浅拷贝就是指针的复制，深拷贝是真正的创建了新对象。</p>

<h4>非集合对象的copy与mutableCopy方法</h4>

<p><p>这里指的是NSString,NSNumber等等一类的对象。
<pre><code>
NSString <em>string = @&ldquo;origin&rdquo;;
NSString </em>stringCopy = [string copy];
NSMutableString <em>stringMCopy = [string mutableCopy];
//可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；
</pre></code>
<p>再看下面的例子
<pre><code>
NSMutableString </em>string = [NSMutableString stringWithString: @&ldquo;origion&rdquo;];
NSString <em>stringCopy = [string copy];
NSMutableString </em>mStringCopy = [string copy];
NSMutableString *stringMCopy = [string mutableCopy];[mStringCopy appendString:@&ldquo;mm&rdquo;];//error
[string appendString:@&ldquo; origion!&rdquo;];
[stringMCopy appendString:@&ldquo;!!&rdquo;];
//以上四个NSString对象所分配的内存都是不一样的。但是对于mStringCopy其实是个imutable对象，所以上述会报错。
对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。
</pre></code></p></blockquote>

<p><p></p>

<h4>集合对象的深拷贝和浅拷贝</h4>

<p>指NSArray，NSDictionary等。对于容器类本身，上面讨论的结论也是适用的，需要探讨的是复制后容器内对象的变化。
<p>
<pre><code>
 //copy返回不可变对象，mutablecopy返回可变对象
 NSArray <em>array1 = [NSArray arrayWithObjects:@&ldquo;a&rdquo;,@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
 NSArray </em>arrayCopy1 = [array1 copy];
 //arrayCopy1是和array同一个NSArray对象（指向相同的对象），包括array里面的元素也是指向相同的指针
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[array1 retainCount]);
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[arrayCopy1 retainCount]);
 NSMutableArray <em>mArrayCopy1 = [array1 mutableCopy];
 //mArrayCopy1是array1的可变副本，指向的对象和array1不同，但是其中的元素和array1中的元素指向的是同一个对象。mArrayCopy1还可以修改自己的对象
[mArrayCopy1 addObject:@&ldquo;de&rdquo;];
[mArrayCopy1 removeObjectAtIndex:0];
//array1和arrayCopy1是指针复制，而mArrayCopy1是对象复制，mArrayCopy1还可以改变期内的元素：删除或添加。但是注意的是，容器内的元素内容都是指针复制。
</pre></code>
<p>下一个例子
<pre><code>
NSArray </em>mArray1 = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;a&rdquo;],@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
NSArray <em>mArrayCopy2 = [mArray1 copy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
NSMutableArray </em>mArrayMCopy1 = [mArray1 mutableCopy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
//mArrayCopy2,mArrayMCopy1和mArray1指向的都是不一样的对象，但是其中的元素都是一样的对象——同一个指针
//一下做测试
NSMutableString <em>testString = [mArray1 objectAtIndex:0];
//testString = @&ldquo;1a1&rdquo;;
//这样会改变testString的指针，其实是将@“1a1”临时对象赋给了testString
[testString appendString:@&ldquo; tail&rdquo;];
//这样以上三个数组的首元素都被改变了
//由此可见，对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝。
</pre></code>
<p>深拷贝
<pre><code>
NSArray </em>array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;first&rdquo;],[NSStringstringWithString:@&ldquo;b&rdquo;],@&ldquo;c&rdquo;,nil];
NSArray <em>deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];
NSArray</em> trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:
[NSKeyedArchiver archivedDataWithRootObject: array]];
//trueDeepCopyArray是完全意义上的深拷贝，而deepCopyArray则不是，对于deepCopyArray内的不可变元素其还是指针复制。或者我们自己实现深拷贝的方法。因为如果容器的某一元素是不可变的，那你复制完后该对象仍旧是不能改变的，因此只需要指针复制即可。除非你对容器内的元素重新赋值，否则指针复制即已足够。
</pre></code></p>

<h4>自定义对象</h4>

<p>如果是我们定义的对象，那么我们自己要实现NSCopying,NSMutableCopying这样就能调用copy和mutablecopy了。
<pre><code>
@interface MyObj : NSObject&lt;NSCopying,NSMutableCopying>
{
         NSMutableString <em>name;
         NSString </em>imutableStr;
         int age;
}
@property (nonatomic, retain) NSMutableString <em>name;
@property (nonatomic, retain) NSString </em>imutableStr;
@property (nonatomic) int age;
@end
@implementation MyObj
@synthesize name;
@synthesize age;
@synthesize imutableStr;
- (id)init
{
         if (self = [super init])
         {
                   self.name = [[NSMutableString alloc]init];
                   self.imutableStr = [[NSString alloc]init];
                   age = -1;
         }
         return self;
}
- (void)dealloc
{
         [name release];
         [imutableStr release];
         [super dealloc];
}
- (id)copyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = [[[self class] allocWithZone:zone] init];
         copy->name = [name copy];
         copy->imutableStr = [imutableStr copy];
//       copy->name = [name copyWithZone:zone];;
//       copy->imutableStr = [name copyWithZone:zone];//
         copy->age = age;
         return copy;
}
- (id)mutableCopyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = NSCopyObject(self, 0, zone);
         copy->name = [self.name mutableCopy];
         copy->age = age;
         return copy;
}
</pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shi-xian-descriptionfang-fa.html/">实现description方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-25T16:05:11+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:05 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>实现description方法</h2>

<blockquote><p>当想打印对象的信息时，对象会收到description消息，该方法返回的描述信息回取代“格式字符串”里的“%@”。</p></blockquote>

<p><p>
<pre><code>
NSArray *object = @[@&ldquo;a string, @(123)&rdquo;];
NSLog(@&ldquo;object = %@&rdquo;,object);</p>

<p>//如果是打印 会输出
object = (
    &ldquo;a string&rdquo;,
    123
)</p>

<p>//如果在自定义的类上这么做  则会打印
object = &lt;EOCPerson: 0x7fd9a1660600></p>

<p></pre></code></p>

<blockquote><p>但是 这样的打印 如果不需要 类名 和 地址的话 ，这个打印毫无意义。so 我们需要复写 description方法。</p></blockquote>

<p><pre><code>
EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&ldquo;Bob&rdquo; lastName:@&ldquo;Smith&rdquo;];
NSLog(@&ldquo;person = %@&rdquo;, person);</p>

<p>该类的description方法通常是这样实现的
-(NSString*) description{
    return [NSStringstringWithFormat:@&ldquo;&lt;%@: %p, \&rdquo;%@ %@\&ldquo;>&rdquo;,[self class], self, <em>firstName, </em>lastName];
}</p>

<p>//打印结果
person = &lt;EOCPerson: 0x7fd9a1660600, &ldquo;Bob Smith&rdquo;>
</pre></code></p>

<blockquote><p><code>作者建议:</code>在新实现的description方法中，也应该像默认的实现那样，打印出类的名字和指针地址，因为这些内容有时也会用到。NSArray类的对象就没有打印这两项内容，显然没有固定规律可循。<code>用NSDicionary来实现此功能可以使代码更以维护.</code></p></blockquote>

<p><p>debugDescription</p>

<blockquote><p>此方法的用意与description非常相似。区别在于前者是开发者在调试器中以控制台命令打印对象时才调用的。用法和description类似.</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 张昊煜 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
