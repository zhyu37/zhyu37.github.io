
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>有所为，有所不为</title>
  <meta name="author" content="张昊煜">

  
  <meta name="description" content="iOS开发之深拷贝与浅拷贝 如有错误请大家多多指教，请大家多关注 https://github.com/zhyu37 对象拷贝分为两种方式：浅拷贝和深拷贝，其实就是copy和retain的区别。copy是创建一个新对象，而retain是创建一个指针，引用计数加1.copy属性表示两个对象内容相同 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhyu37.github.io/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="有所为，有所不为" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">有所为，有所不为</a></h1>
  
    <h2>张昊煜</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="zhyu37.github.io" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ioskai-fa-zhi-shen-kao-bei-,-qian-kao-bei.html/">iOS开发之深拷贝、浅拷贝</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-01T17:01:32+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:01 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>iOS开发之深拷贝与浅拷贝</h2>

<p><p>
<code>如有错误请大家多多指教，请大家多关注 https://github.com/zhyu37</code></p>

<blockquote><p>对象拷贝分为两种方式：浅拷贝和深拷贝，其实就是copy和retain的区别。copy是创建一个新对象，而retain是创建一个指针，引用计数加1.<code>copy属性</code>表示两个对象内容相同，新对象的retain引用计数为1，和旧的对象毫无关系了。<code>retain属性</code>仅仅是复制了旧对象的指针，内容相同，但是retain引用计数为2.总体来说就是浅拷贝就是指针的复制，深拷贝是真正的创建了新对象。</p>

<h4>非集合对象的copy与mutableCopy方法</h4>

<p><p>这里指的是NSString,NSNumber等等一类的对象。
<pre><code>
NSString <em>string = @&ldquo;origin&rdquo;;
NSString </em>stringCopy = [string copy];
NSMutableString <em>stringMCopy = [string mutableCopy];
//可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；
</pre></code>
<p>再看下面的例子
<pre><code>
NSMutableString </em>string = [NSMutableString stringWithString: @&ldquo;origion&rdquo;];
NSString <em>stringCopy = [string copy];
NSMutableString </em>mStringCopy = [string copy];
NSMutableString *stringMCopy = [string mutableCopy];[mStringCopy appendString:@&ldquo;mm&rdquo;];//error
[string appendString:@&ldquo; origion!&rdquo;];
[stringMCopy appendString:@&ldquo;!!&rdquo;];
//以上四个NSString对象所分配的内存都是不一样的。但是对于mStringCopy其实是个imutable对象，所以上述会报错。
对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。
</pre></code></p></blockquote>

<p><p></p>

<h4>集合对象的深拷贝和浅拷贝</h4>

<p>指NSArray，NSDictionary等。对于容器类本身，上面讨论的结论也是适用的，需要探讨的是复制后容器内对象的变化。
<p>
<pre><code>
 //copy返回不可变对象，mutablecopy返回可变对象
 NSArray <em>array1 = [NSArray arrayWithObjects:@&ldquo;a&rdquo;,@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
 NSArray </em>arrayCopy1 = [array1 copy];
 //arrayCopy1是和array同一个NSArray对象（指向相同的对象），包括array里面的元素也是指向相同的指针
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[array1 retainCount]);
    NSLog(@&ldquo;array1 retain count: %d&rdquo;,[arrayCopy1 retainCount]);
 NSMutableArray <em>mArrayCopy1 = [array1 mutableCopy];
 //mArrayCopy1是array1的可变副本，指向的对象和array1不同，但是其中的元素和array1中的元素指向的是同一个对象。mArrayCopy1还可以修改自己的对象
[mArrayCopy1 addObject:@&ldquo;de&rdquo;];
[mArrayCopy1 removeObjectAtIndex:0];
//array1和arrayCopy1是指针复制，而mArrayCopy1是对象复制，mArrayCopy1还可以改变期内的元素：删除或添加。但是注意的是，容器内的元素内容都是指针复制。
</pre></code>
<p>下一个例子
<pre><code>
NSArray </em>mArray1 = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;a&rdquo;],@&ldquo;b&rdquo;,@&ldquo;c&rdquo;,nil];
NSArray <em>mArrayCopy2 = [mArray1 copy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
NSMutableArray </em>mArrayMCopy1 = [mArray1 mutableCopy];
NSLog(@&ldquo;mArray1 retain count: %d&rdquo;,[mArray1 retainCount]);
//mArrayCopy2,mArrayMCopy1和mArray1指向的都是不一样的对象，但是其中的元素都是一样的对象——同一个指针
//一下做测试
NSMutableString <em>testString = [mArray1 objectAtIndex:0];
//testString = @&ldquo;1a1&rdquo;;
//这样会改变testString的指针，其实是将@“1a1”临时对象赋给了testString
[testString appendString:@&ldquo; tail&rdquo;];
//这样以上三个数组的首元素都被改变了
//由此可见，对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝。
</pre></code>
<p>深拷贝
<pre><code>
NSArray </em>array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&ldquo;first&rdquo;],[NSStringstringWithString:@&ldquo;b&rdquo;],@&ldquo;c&rdquo;,nil];
NSArray <em>deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];
NSArray</em> trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:
[NSKeyedArchiver archivedDataWithRootObject: array]];
//trueDeepCopyArray是完全意义上的深拷贝，而deepCopyArray则不是，对于deepCopyArray内的不可变元素其还是指针复制。或者我们自己实现深拷贝的方法。因为如果容器的某一元素是不可变的，那你复制完后该对象仍旧是不能改变的，因此只需要指针复制即可。除非你对容器内的元素重新赋值，否则指针复制即已足够。
</pre></code></p>

<h4>自定义对象</h4>

<p>如果是我们定义的对象，那么我们自己要实现NSCopying,NSMutableCopying这样就能调用copy和mutablecopy了。
<pre><code>
@interface MyObj : NSObject&lt;NSCopying,NSMutableCopying>
{
         NSMutableString <em>name;
         NSString </em>imutableStr;
         int age;
}
@property (nonatomic, retain) NSMutableString <em>name;
@property (nonatomic, retain) NSString </em>imutableStr;
@property (nonatomic) int age;
@end
@implementation MyObj
@synthesize name;
@synthesize age;
@synthesize imutableStr;
- (id)init
{
         if (self = [super init])
         {
                   self.name = [[NSMutableString alloc]init];
                   self.imutableStr = [[NSString alloc]init];
                   age = -1;
         }
         return self;
}
- (void)dealloc
{
         [name release];
         [imutableStr release];
         [super dealloc];
}
- (id)copyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = [[[self class] allocWithZone:zone] init];
         copy->name = [name copy];
         copy->imutableStr = [imutableStr copy];
//       copy->name = [name copyWithZone:zone];;
//       copy->imutableStr = [name copyWithZone:zone];//
         copy->age = age;
         return copy;
}
- (id)mutableCopyWithZone:(NSZone <em>)zone
{
         MyObj </em>copy = NSCopyObject(self, 0, zone);
         copy->name = [self.name mutableCopy];
         copy->age = age;
         return copy;
}
</pre></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/shi-xian-descriptionfang-fa.html/">实现description方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-25T16:05:11+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:05 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>实现description方法</h2>

<blockquote><p>当想打印对象的信息时，对象会收到description消息，该方法返回的描述信息回取代“格式字符串”里的“%@”。</p></blockquote>

<p><p>
<pre><code>
NSArray *object = @[@&ldquo;a string, @(123)&rdquo;];
NSLog(@&ldquo;object = %@&rdquo;,object);</p>

<p>//如果是打印 会输出
object = (
    &ldquo;a string&rdquo;,
    123
)</p>

<p>//如果在自定义的类上这么做  则会打印
object = &lt;EOCPerson: 0x7fd9a1660600></p>

<p></pre></code></p>

<blockquote><p>但是 这样的打印 如果不需要 类名 和 地址的话 ，这个打印毫无意义。so 我们需要复写 description方法。</p></blockquote>

<p><pre><code>
EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&ldquo;Bob&rdquo; lastName:@&ldquo;Smith&rdquo;];
NSLog(@&ldquo;person = %@&rdquo;, person);</p>

<p>该类的description方法通常是这样实现的
-(NSString*) description{
    return [NSStringstringWithFormat:@&ldquo;&lt;%@: %p, \&rdquo;%@ %@\&ldquo;>&rdquo;,[self class], self, <em>firstName, </em>lastName];
}</p>

<p>//打印结果
person = &lt;EOCPerson: 0x7fd9a1660600, &ldquo;Bob Smith&rdquo;>
</pre></code></p>

<blockquote><p><code>作者建议:</code>在新实现的description方法中，也应该像默认的实现那样，打印出类的名字和指针地址，因为这些内容有时也会用到。NSArray类的对象就没有打印这两项内容，显然没有固定规律可循。<code>用NSDicionary来实现此功能可以使代码更以维护.</code></p></blockquote>

<p><p>debugDescription</p>

<blockquote><p>此方法的用意与description非常相似。区别在于前者是开发者在调试器中以控制台命令打印对象时才调用的。用法和description类似.</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/li-jie-lei-dui-xiang-de-yong-yi.html/">查询类的类型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-10T09:20:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:20 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十四条 理解“类对象”的用意</h2>

<blockquote><p>每个实例都用一个指向Class对象的指针，用来表示其类型。如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</p></blockquote>

<pre><code>
NSMutableDictionary *dict = [NSMutableDictionary new];
//判断对象是否是否个特定类的实例
[dict isMemberofClass:[NSDictionary class]];//NO
[dict isMemberofClass:[NSMutableDictionary class]];//Yes
//判断对象是否为某个类或其派生类的实例
[dict isKindofClass:[NSDictionary class]];//Yes
[dict isKindofClass:[NSArray class]];//No
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/method-swizzling.html/">Method Swizzling</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-09T13:08:45+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十三条  用“方法调配技术”调试“黑盒方法”</h2>

<blockquote><p>在没有一个类的源码时，例如调用别人API时。想改变其中一个方法的实现，除了继承重写、借助重类名方法之外，现在还发现了一种新的方法——Method Swizzling。</p></blockquote>

<p>一个NSString类的例子</p>


<pre><code>
//头文件 
#import  <objc/runtime.h>

//具体实现
 //1.测试字符串
    NSString *str = @"Hello World";
    
//2.打印正常方法调用的值
    NSLog(@"%@ %@",[str lowercaseString],[str uppercaseString]);
    
Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
    Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));
    method_exchangeImplementations(originalMethod, swappedMethod);
    
 //4.打印方法调配后的值
    NSLog(@"%@ %@",[str lowercaseString],[str uppercaseString]);
</pre>


<p></code></p>

<p><p>打印结果
<pre><code>
2015-11-09 12:49:23.361 ChangeMethods[810:459887] hello world HELLO WORLD
2015-11-09 12:49:23.362 ChangeMethods[810:459887] HELLO WORLD hello world
</pre></code></p>

<blockquote><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。
每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，
我们可以利用 class_replaceMethod 来修改类，
我们可以利用 method_setImplementation 来直接设置某个方法的IMP</p>

<h2>See You</h2></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/objc-msgsendde-zuo-yong.html/">objc_msgSend的作用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-01T21:51:47+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>9:51 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>第十一条  objc_msgSend的作用</h2>

<blockquote><p>objc_msgSend是obj-c中经常用到的一个功能，当你在对象上调用方法时就用用到这个——消息传递。</p></blockquote>

<pre><code>
id returnValue = [someObject messageName:parameter];
</pre>


<p></code>
<li>someObject 是对象
<li>messageName 为对象所属的方法
<li>parameter 为方法所需要的参数</p>

<p><code>messageName:parameter 叫选择子(selector)</code>   <br/>
<code>someObject  叫接收者(receiver)</code></p>

<blockquote><p>objc_msgSend的底层使用C写的，C的方法调用是<code>静态绑定(static bingding)</code>把方法硬编码到指令中，当需要时直接调用。C还可以使用<code>动态绑定(dynamic bingding)</code>在指令中只有一个函数调用指令，在运行期读取出来。objc是一门真正的动态语言.</p></blockquote>

<pre><code>
//objc 的底层会把id returnValue = [someObject messageName:parameter];转换成
id returnValue = objc_msgSend(someObject,
                                @selector(messageName),
                                parameter);
</pre>


<p></code></p>

<blockquote><p>在objc_msgSend中还用到了<code>尾调用优化</code>就是在结尾的时候调用另一个函数时，编译器是生成调转另一个函数的指令码，不会推入堆栈中。</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/textgame.html/">textGame</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-01T20:24:45+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>8:24 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>一个能看出你是否长大的测试</h2>

<p><img src="../images/2015image1.png" alt="Alt text" /></p>

<blockquote><p>一男人M要与未婚妻F相会结婚，但两人一河相隔，M必须要借船过河才能见到F，于是他开始四处找船。 这时见一个女子L刚好有船，M跟L借，L遇到M后爱上了他，就问：我爱上你了，你爱我吗？M比较诚实，说：对不起，我有未婚妻，我不能爱你。这么一来，L死活是不把船借给M，她的理由是：我爱你，你不爱我，这不公平，我不会借你的！M很沮丧，继续找船，刚好见一位叫S的女子，就向她借船，S说：我借给你没问题，但有个条件，我很喜欢你，你是不是喜欢我所谓，但你必须留下陪我一晚， 不然我不借你。M很为难，L不借他船，S如果再不借他的话就过不去河与F相见了，据说这个地方只有这两条船。为了彼岸的未婚妻，他不得不同意了S的要求， 与S有了NB。次日，S遵守承诺把船借给了M。 见到未婚妻F后，M一直心里有事，考虑了很久，终于决定把向L和S借船的故事跟F说了。可惜，F听了非常伤心，一气之下与M分了手，她觉得M不忠，不能原谅。F失恋了，很受打击。 这时他的生活里出现了位女子E，两人也开始恋爱了，但之前的故事一直让他耿耿于坏，E问M是不是有什么话要跟她说，于是，M一五一十地把他和L、S、F之间的故事讲了一遍。E听了后，说，我不会介意的，这些跟我没关系。
 <li>
  <li>
   <li>
   <li>
   <li>
   <li>
   <li>
   <li>
 <li>
   <li>
   <li>
    <li>
 <p>答案
<img src="../images/2015image2.png" alt="Alt text" /></p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ios-auto-layout.html/">Ios Auto Layout</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-25T20:27:46+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:27 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>Ios Auto Layout</h2>

<blockquote><p>一开始 学的时候frame的绝对位置确实比autLayout好用，但是随着iphone 的尺寸越来越多 就会发现在4寸屏上适配成功，发现到plus 上就不对了。so 我选择了autoLayout 因为他是相对布局 所以它更适合 尺寸的变换和 竖屏横屏的切换。但也不能说frame 没用处。</p></blockquote>

<p>autolayout的VFL(Visual Format Language)语法</p>




<pre><code>
NSString *vfl = @"V:|-5-[_view]-10-[_imageView(20)]-10-[_backBtn]-5-|";

//其实这段话就是说，在垂直方向从上到下，view离父视图5点，imageView距离view 10点，同时imageView是20点高，backBtn离imageView底部10点，距离父视图底部5点。
</pre>


<p></code></p>

<p>手动Constraint书写</p>


<pre><code>
[self.view addConstraint: [NSLayoutConstraint constraintWithItem:blueView
attribute:NSLayoutAttributeLeft
relatedBy:NSLayoutRelationEqual
toItem:redView
attribute:NSLayoutAttributeLeft
multiplier:1
constant:0]];
</pre>


<p></code></p>

<blockquote><p>通过上面的 讲解  发现AutoLayout还需要花费经历 再去学习一番。SO 我在github上发现了一位大神写的第三方的东西<code>Masonry</code>.<a href="https://github.com/SnapKit/Masonry">https://github.com/SnapKit/Masonry</a><br/>
开源项目Masonry旨在让自动布局（Auto Layout）的代码更简洁、可读性更强。</p>

<p>Masonry ，“一个轻量级的布局框架，采用更优雅的语法封装自动布局”，不需要使用XIB和Storyboard。它的创造者Jonas Budelmann 论证 了尽管自动布局很强大，但它很快就变得冗长而不可读。</p>

<p>Masonry是一种领域特定语言（DSL），为自动布局的所有功能提供便捷的方法，包括建立和修改约束、存取属性、设置优先级以及调试支持。</p></blockquote>

<p>view的x位于父视图中心，y距顶部5，width为10，hight为20。还是同样地意思 我用这种框架来写一下</p>


<pre><code>
[view mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.equalTo(self.mas_centerX);
        make.top.equalTo(self.mas_top).offset(5);
        make.width.equalTo(@(10));
        make.height.equalTo(@(20));
    }];
</pre>


<p></code></p>

<p>感觉还是很好用的</p>


<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/uipickerview.html/">UIPickerView</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-22T23:25:30+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>11:25 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>UIPickerView</h2>

<blockquote><p>UIPickerView是一个类似于选择器的东西。</p></blockquote>

<ul>
<li>UIPickerViewDelegate

<ul>
<li>//pikerView 的长度
(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component;</li>
<li>//pickerView 的宽度
(CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component;</li>
<li>//pickerView 里面的信息
(NSString <em>)pickerView:(UIPickerView </em>)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component;</li>
<li>//当被点击后执行
(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component;</li>
</ul>
</li>
<li>UIPickerViewDataSource

<ul>
<li>//pickerView 的个数
(NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView</li>
<li>//每个pickerView 的行数
(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component</li>
</ul>
</li>
</ul>


<p>pickerView初始化</p>


<pre><code>
@property (nonatomic, strong) UIPickerView *pickerView;


- (void)viewDidLoad {
// 显示选中框 default = NO
    self.pickerView.showsSelectionIndicator=YES;
    self.pickerView.dataSource = self;
    self.pickerView.delegate = self;
    [self.view addSubview:self.pickerView];
}


- (UIPickerView *)pickerView
{
    if (!_pickerView) {
        _pickerView = [[UIPickerView alloc] initWithFrame:CGRectMake(0, 0, 320, 480)];
    }
    return _pickerView;
}
</pre>


<p></code></p>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/iosduan-wei-xin-zhi-fu-demo.html/">Ios端 微信支付Demo</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-17T09:08:37+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:08 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<h2>ios端 微信支付</h2>

<blockquote><p>最近项目上用到了微信支付，看官方文档我也不想说什么，只是没有友盟、环信之类写的清楚，Demo居然 还是一个学C的ios实习生写的我也是醉了。所以我精简了一些一般常用的，希望大家指点不足。</p></blockquote>

<p>准备工作  从官方文档下载SDK</p>


<ul>
<li>SDKExpot(里面包含三个文件)</li>
<li>ApiXml.h/.m</li>
<li>WXUtil.h/.m</li>
</ul>


<blockquote><p>把这些文件导入到工程里，然后我们再里面创建一个工具类</p></blockquote>

<p>WeChatPayManager.h</p>


<pre><code>
#import Foundation/Foundation.h
#import "WXApi.h"
#import "WXUtil.h"
#import "ApiXml.h"

// 账号帐户资料
// 更改商户把相关参数后可测试   因为涉及到隐私所以就不公布了  哈哈
//appid  公众账号ID
#define APP_ID          @""  
//appsecret,看起来好像没用     
#define APP_SECRET      @""  
//商户号，mch_id
#define MCH_ID          @""
//商户API密钥，填写相应参数
#define PARTNER_ID      @""
//支付结果回调页面
#define NOTIFY_URL      @"http://wxpay.weixin.qq.com/pub_v2/pay/notify.v2.php"
//获取服务器端支付数据地址（商户自定义）(在这里，签名算法直接放在APP端，故不需要自定义)
#define SP_URL          @"http://wxpay.weixin.qq.com/pub_v2/app/app_pay.php"

@interface TDUWeChatPayManager : NSObject
+ (instancetype)sharedTDUWeChatPayManager;

//预支付网关url地址
@property (nonatomic,strong) NSString* payUrl;
@property (nonatomic,strong) NSString* chatUrl;

//debug信息
@property (nonatomic,strong) NSMutableString *debugInfo;
@property (nonatomic,assign) NSInteger lastErrCode;//返回的错误码

//商户关键信息
@property (nonatomic,strong) NSString *appId,*mchId,*spKey;

//获取当前的debug信息
-(NSString *) getDebugInfo;

//获取预支付订单信息（核心是一个prepayID）
- (NSMutableDictionary*)getPrepayWithOrder
 Name:(NSString*)name
price:(NSString*)price
 device:(NSString*)device
 norder:(NSString*)orderno;

//查询订单  返回 所需要的信息
- (NSString*)getOrderIDorderno:(NSString*)orderno;

//这里就是调用支付的方法  name 为你要传的商品名称  price 支付的金额注意金额 单位 是分  
//orderno  是一组随机数  就是文档里的  随机字符串  nonce_str 我这里使用是因为 有的地方 要用
- (void)wxPayWithOrderName:(NSString*)name price:(NSString*)price orderno:(NSString*)orderno;

@end

</pre>


<p></code></p>

<p>WeChatPayManager.m</p>




<pre><code>
#import "TDUWeChatPayManager.h"

@interface TDUWeChatPayManager()

@property (nonatomic, copy) NSString *orderno;

@end
static TDUWeChatPayManager *manager = nil;
@implementation TDUWeChatPayManager

+ (instancetype)sharedTDUWeChatPayManager
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        manager = [[TDUWeChatPayManager alloc] initWithAppID:APP_ID mchID:MCH_ID spKey:PARTNER_ID];
    });
    return manager;
}


//初始化函数
-(id)initWithAppID:(NSString*)appID mchID:(NSString*)mchID spKey:(NSString*)key
{
    self = [super init];
    if(self)
    {
        //初始化私有参数，主要是一些和商户有关的参数
        self.payUrl    = @"https://api.mch.weixin.qq.com/pay/unifiedorder";
        self.chatUrl = @"https://api.mch.weixin.qq.com/pay/orderquery";
        if (self.debugInfo == nil){
            self.debugInfo  = [NSMutableString string];
        }
        [self.debugInfo setString:@""];
        self.appId = appID;//微信分配给商户的appID
        self.mchId = mchID;//
        self.spKey = key;//商户的密钥
    }
    return self;
}

//获取debug信息
-(NSString*) getDebugInfo
{
    NSString *res = [NSString stringWithString:self.debugInfo];
    [self.debugInfo setString:@""];
    return res;
}

//创建package签名
-(NSString*) createMd5Sign:(NSMutableDictionary*)dict
{
    NSMutableString *contentString  =[NSMutableString string];
    NSArray *keys = [dict allKeys];
    //按字母顺序排序
    NSArray *sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
        return [obj1 compare:obj2 options:NSNumericSearch];
    }];
    //拼接字符串
    for (NSString *categoryId in sortedArray) {
        if (   ![[dict objectForKey:categoryId] isEqualToString:@""]
            && ![categoryId isEqualToString:@"sign"]
            && ![categoryId isEqualToString:@"key"]
            )
        {
            [contentString appendFormat:@"%@=%@&", categoryId, [dict objectForKey:categoryId]];
        }
        
    }
    //添加key字段
    [contentString appendFormat:@"key=%@", self.spKey];
    //得到MD5 sign签名
    NSString *md5Sign =[WXUtil md5:contentString];
    
    //输出Debug Info
    [self.debugInfo appendFormat:@"MD5签名字符串：\n%@\n\n",contentString];
    
    return md5Sign;
}

//获取package带参数的签名包
-(NSString *)genPackage:(NSMutableDictionary*)packageParams
{
    NSString *sign;
    NSMutableString *reqPars=[NSMutableString string];
    //生成签名
    sign        = [self createMd5Sign:packageParams];
    //生成xml的package
    NSArray *keys = [packageParams allKeys];
    [reqPars appendString:@"<xml>\n"];
    for (NSString *categoryId in keys) {
        [reqPars appendFormat:@"<%@>%@</%@>\n",categoryId, [packageParams objectForKey:categoryId],categoryId];
    }
    [reqPars appendFormat:@"<sign>%@</sign>\n</xml>", sign];
    
    return [NSString stringWithString:reqPars];
}

//提交预支付
-(NSString *)sendPrepay:(NSMutableDictionary *)prePayParams
{
    NSString *prepayid = nil;
    
    //获取提交支付
    NSString *send      = [self genPackage:prePayParams];
    
    //输出Debug Info
    [self.debugInfo appendFormat:@"API链接:%@"
     , self.payUrl];
    [self.debugInfo appendFormat:@"发送的xml:%@"
     , send];
    
    //发送请求post xml数据
    NSData *res = [WXUtil httpSend:self.payUrl method:@"POST" data:send];
    
    //输出Debug Info
    [self.debugInfo appendFormat:@"服务器返回：%@"
     
     ,[[NSString alloc] initWithData:res encoding:NSUTF8StringEncoding]];
    
    XMLHelper *xml  = [[XMLHelper alloc] init];
    
    //开始解析
    [xml startParse:res];
    
    NSMutableDictionary *resParams = [xml getDict];
    
    //判断返回
    NSString *return_code   = [resParams objectForKey:@"return_code"];
    NSString *result_code   = [resParams objectForKey:@"result_code"];
    if ( [return_code isEqualToString:@"SUCCESS"] )
    {
        //生成返回数据的签名
        NSString *sign      = [self createMd5Sign:resParams ];
        NSString *send_sign =[resParams objectForKey:@"sign"] ;
        
        //验证签名正确性
        if( [sign isEqualToString:send_sign]){
            if( [result_code isEqualToString:@"SUCCESS"]) {
                //验证业务处理状态
                prepayid    = [resParams objectForKey:@"prepay_id"];
                return_code = 0;
                
                [self.debugInfo appendFormat:@"获取预支付交易标示成功！"
                 ];
            }
        }else{
            self.lastErrCode = 1;
            [self.debugInfo appendFormat:@"gen_sign=%@_sign=%@"
             ,sign,send_sign];
            [self.debugInfo appendFormat:@"服务器返回签名验证错误！！！"
             ];
        }
    }else{
        self.lastErrCode = 2;
        [self.debugInfo appendFormat:@"接口返回错误！！！"
         ];
    }
    
    return prepayid;
}

- (NSMutableDictionary*)getPrepayWithOrderName:(NSString*)name
                                         price:(NSString*)price
                                        device:(NSString*)device
                                        norder:(NSString*)orderno
{
    //订单标题，展示给用户
    NSString* orderName = name;
    //订单金额,单位（分）
    NSString* orderPrice = price;//以分为单位的整数
    //支付设备号或门店号
    NSString* orderDevice = device;
    //支付类型，固定为APP
    NSString* orderType = @"APP";
    //发器支付的机器ip,暂时没有发现其作用
    NSString* orderIP = @"196.168.7.96";
    
    //================================
    //预付单参数订单设置
    //================================
    srand( (unsigned)time(0) );
    NSString *noncestr  = [NSString stringWithFormat:@"%d", rand()];
    self.orderno  = [NSString stringWithFormat:@"%ld",time(0)];
    NSMutableDictionary *packageParams = [NSMutableDictionary dictionary];
    
    [packageParams setObject: self.appId        forKey:@"appid"];       //开放平台appid
    [packageParams setObject: self.mchId        forKey:@"mch_id"];      //商户号
    [packageParams setObject: [TDUGlobal sharedTDUGlobal].deviceToken        forKey:@"device_info"]; //支付设备号或门店号
    [packageParams setObject: noncestr          forKey:@"nonce_str"];   //随机串
    [packageParams setObject: orderType            forKey:@"trade_type"];  //支付类型，固定为APP
    [packageParams setObject: orderName        forKey:@"body"];        //订单描述，展示给用户
    [packageParams setObject: NOTIFY_URL        forKey:@"notify_url"];  //支付结果异步通知
    [packageParams setObject: orderno           forKey:@"out_trade_no"];//商户订单号
    [packageParams setObject: orderIP    forKey:@"spbill_create_ip"];//发器支付的机器ip
    [packageParams setObject: orderPrice       forKey:@"total_fee"];       //订单金额，单位为分
    
    //获取prepayId（预支付交易会话标识）
    NSString *prePayid;
    prePayid = [self sendPrepay:packageParams];
    
    if(prePayid == nil)
    {
        [self.debugInfo appendFormat:@"获取prepayid失败！"
         ];
        return nil;
    }
    
    //获取到prepayid后进行第二次签名
    NSString    *package, *time_stamp, *nonce_str;
    //设置支付参数
    time_t now;
    time(&now);
    time_stamp  = [NSString stringWithFormat:@"%ld", now];
    nonce_str = [WXUtil md5:time_stamp];
    //重新按提交格式组包，微信客户端暂只支持package=Sign=WXPay格式，须考虑升级后支持携带package具体参数的情况
    //package       = [NSString stringWithFormat:@Sign=%@,package];
    package         = @"Sign=WXPay";
    //第二次签名参数列表
    NSMutableDictionary *signParams = [NSMutableDictionary dictionary];
    [signParams setObject: self.appId  forKey:@"appid"];
    [signParams setObject: self.mchId  forKey:@"partnerid"];
    [signParams setObject: nonce_str    forKey:@"noncestr"];
    [signParams setObject: package      forKey:@"package"];
    [signParams setObject: time_stamp   forKey:@"timestamp"];
    [signParams setObject: prePayid     forKey:@"prepayid"];
    
    //生成签名
    NSString *sign  = [self createMd5Sign:signParams];
    
    //添加签名
    [signParams setObject: sign         forKey:@"sign"];
    
    [self.debugInfo appendFormat:@"第二步签名成功，sign＝%@"
     ,sign];
    
    //返回参数列表
    return signParams;
}

//官方文档中的  统一下单
- (void)wxPayWithOrderName:(NSString*)name price:(NSString*)price orderno:(NSString*)orderno
{
    //创建支付签名对象 && 初始化支付签名对象
    TDUWeChatPayManager *wxpayManager = [TDUWeChatPayManager sharedTDUWeChatPayManager];
    
    //获取到实际调起微信支付的参数后，在app端调起支付
    //生成预支付订单，实际上就是把关键参数进行第一次加密。
    NSString* device = @"013467007045764";
    NSMutableDictionary *dict = [wxpayManager getPrepayWithOrderName:name price:price device:device norder:orderno];
    
    if(dict == nil){
        //错误提示
        NSString *debug = [wxpayManager getDebugInfo];
        return;
    }
    
    NSMutableString *stamp  = [dict objectForKey:@"timestamp"];
    
    //调起微信支付
    PayReq* req             = [[PayReq alloc] init];
    req.openID              = [dict objectForKey:@"appid"];
    req.partnerId           = [dict objectForKey:@"partnerid"];
    req.prepayId            = [dict objectForKey:@"prepayid"];
    req.nonceStr            = [dict objectForKey:@"noncestr"];
    req.timeStamp           = stamp.intValue;
    req.package             = [dict objectForKey:@"package"];
    req.sign                = [dict objectForKey:@"sign"];
    
    //        BOOL flag = [WXApi sendReq:req];
    [WXApi sendReq:req];
}

//官方文档中的  查询订单
- (NSString*)getOrderIDorderno:(NSString*)orderno
{
    srand( (unsigned)time(0) );
    NSString *noncestr  = [NSString stringWithFormat:@"%d", rand()];
    NSMutableDictionary *packageParams = [NSMutableDictionary dictionary];
    
    [packageParams setObject: self.appId        forKey:@"appid"];       //开放平台appid
    [packageParams setObject: self.mchId        forKey:@"mch_id"];      //商户号
    [packageParams setObject: orderno           forKey:@"out_trade_no"];//商户订单号
    [packageParams setObject: noncestr          forKey:@"nonce_str"];   //随机串
    
    NSString *prePayid;
    prePayid = [self querySendPrepay:packageParams];
    
    return prePayid;
    
}

//提交预支付
-(NSString *)querySendPrepay:(NSMutableDictionary *)prePayParams
{
    NSString *prepayid = nil;
    
    //获取提交支付
    NSString *send      = [self genPackage:prePayParams];
    
    //输出Debug Info
    [self.debugInfo appendFormat:@"API链接:%@"
     , self.payUrl];
    [self.debugInfo appendFormat:@"发送的xml:%@"
     , send];
    
    //发送请求post xml数据
    NSData *res = [WXUtil httpSend:self.chatUrl method:@"POST" data:send];
    
    //输出Debug Info
    [self.debugInfo appendFormat:@"服务器返回：%@"
     
     ,[[NSString alloc] initWithData:res encoding:NSUTF8StringEncoding]];
    
    XMLHelper *xml  = [[XMLHelper alloc] init];
    
    //开始解析
    [xml startParse:res];
    
    NSMutableDictionary *resParams = [xml getDict];
    
    //判断返回
    NSString *return_code   = [resParams objectForKey:@"return_code"];
    NSString *result_code   = [resParams objectForKey:@"result_code"];
    if ( [return_code isEqualToString:@"SUCCESS"] )
    {
        if ([result_code isEqualToString:@"SUCCESS"]) {
            return resParams[@"transaction_id"];
        }
    }
    
    return nil;
}
@end

</pre>


<p></code></p>

<p>AppDelegate.m</p>




<pre><code>
#import "WXApi.h"
@interface AppDelegate ()WXApiDelegate

#pragma mark - WXApiDelegate

//当支付完成之后  之后调用
-(void) onResp:(BaseResp*)resp
{
    //启动微信支付的response
    NSString *strMsg = [NSString stringWithFormat:@"errcode:%d", resp.errCode];
    if([resp isKindOfClass:[PayResp class]]){
        
        //支付返回结果，实际支付结果需要去微信服务器端查询
        switch (resp.errCode) {
            case 0:
            //通过 通知调用 支付界面的  上传服务器的接口 
                [[NSNotificationCenter defaultCenter] postNotificationName:TDUWeChatPaySuccessNotification object:nil];
                strMsg = @"支付结果：成功！";
                break;
            case -1:
                strMsg = @"支付结果：失败！";
                break;
            case -2:
                strMsg = @"用户已经退出支付！";
                break;
            default:
                strMsg = [NSString stringWithFormat:@"支付结果：失败！retcode = %d, retstr = %@", resp.errCode,resp.errStr];
                break;
        }
    }
}


- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url
{
    return  [WXApi handleOpenURL:url delegate:self];
}

- (BOOL)application:(UIApplication *)application
                     openURL:(NSURL *)url
           sourceApplication:(NSString *)sourceApplication
                  annotation:(id)annotation
{
    BOOL isSuc = [WXApi handleOpenURL:url delegate:self];
    
    NSLog(@"url %@ isSuc %d",url,isSuc == YES ? 1 : 0);
    
    return  isSuc;
}

</pre>


<p></code></p>

<p>为了 适配io9  还要有一些改变 可以去 微信官方文档上 或者是 网上去找 ，然后就是 把 微信appid添加 到项目中  这个 Demo 中的一张图片上 解释了</p>


<blockquote><p>基本上  就是这样  有不懂的 可以联系我QQ466096851  我上面的版本有的地方是为了 服务器要求上传订单号 ，但是 微信官方文档上面的 支付结果通知  说的返回的 根本没有 或者  是我没有找到，可以根据自己实际情况 做改变.</p></blockquote>

<h2>See You</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/zhuan-zai-ioskai-fa-zong-jie-zhi-dai-ma-gui-fan.html/">转载 iOS开发总结之代码规范</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-15T11:26:23+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:26 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<p>转载 <a href="http://www.cocoachina.com/ios/20151014/13678.html">http://www.cocoachina.com/ios/20151014/13678.html</a>
本文是投稿文章，作者：RylanJIN</p>

<blockquote><p>最近被安排fix项目的随机crash问题, 大大小小修复了差不多10个issue, 总结一下发现这些问题或多或少都是由代码习惯和编程规范引起的, 可见一个好的编码习惯是多么的重要! 趁着这两天休假将自己所认为的一些比较好的代码规范整理一下, 并结合之前遇到的实际case跟大家分享一下.</p></blockquote>

<p>命名规范</p>

<blockquote><p>总的来说, iOS命名两大原则是:可读性高和防止命名冲突(通过加前缀来保证). Objective-C 的命名通常都比较长, 名称遵循驼峰式命名法. 一个好的命名标准很简单, 就是做到在开发者一看到名字时, 就能够懂得它的含义和使用方法. 另外, 每个模块都要加上自己的前缀, 前缀在编程接口中非常重要, 可以区分软件的功能范畴并防止不同文件或者类之间命名发生冲突, 比如相册模块(PhotoGallery)的代码都以PG作为前缀: PGAlbumViewController, PGDataManager.</p></blockquote>

<p>1). 常量的命名</p>

<p>对于常量的命名最好在前面加上字母k作为标记. 如:</p>

<p>1
static const NSTimeInterval kAnimationDuration = 0.3;
定义作为NSDictionary或者Notification等的Key值字符串时加上const关键字, 以防止被修改. 如:</p>

<p>1
NSString *const UIApplicationDidEnterBackgroundNotification
Tips:</p>

<ol type="a">
<li>若常量作用域超出编译单元(实现文件), 需要在类外可见时, 使用extern关键字, 并加上该类名作为前缀. 如 extern NSString *const PGThumbnailSize</li>
</ol>


<p>II.全局常量(通知或者关键字等)尽量用const来定义. 因为如果使用宏定义, 一来宏可能被重定义. 二来引用不同的文件可能会导致宏的不同. P.S. 对于＃define也添加一下前缀k(强迫症, 哈哈&hellip;)</p>

<p>2). 枚举的命名</p>

<p>对于枚举类型, 经常会看到之前的C的定义方式:</p>

<p>1
2
3
4
5
typedef enum : {
    CameraModeFront,
    CameraModeLeft,
    CameraModeRight,
} CameraMode;
不知道是肿么了, 每次看到这种定义方式总是感觉怪怪的, 作为一个正宗的iOS开发者当然要以Objective-C的方式来定义啦, 哈哈&hellip; 那Objective-C是怎么定义的呢? 很简单, 到SDK里面看看Apple是怎么做滴:</p>

<pre><code>
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone,
    UIViewAnimationTransitionFlipFromLeft,
    UIViewAnimationTransitionFlipFromRight,
    UIViewAnimationTransitionCurlUp,
    UIViewAnimationTransitionCurlDown,
};
</pre>


<p></code>
这边需要注意的是: 枚举类型命名要加相关类名前缀并且枚举值命名要加枚举类型前缀.</p>

<p>3). 变量和对象的命名</p>

<p>给一个对象命名时建议采用修饰+类型的方式. 如果只用修饰命名会引起歧义, 比如title (这个到底是个NSString还是UILabel?). 同样的, 如果只用类型来命名则会缺失作用信息, 比如label (好吧, 我知道你是个UILabel, 但是我不知道它是用来做什么的呀?). So, 正确的命名方式为:</p>

<pre><code>
titleLabel    //表示标题的label,  是UILabel类型
confirmButton //表示确认的button, 是UIButton类型
</pre>


<p></code>
对于BOOL类型, 应加上is前缀, 比如- (BOOL)isEqualToString:(NSString <em>)aString这样会更加清晰. 如果某方法返回非属性的 BOOL 值, 那么应根据其功能, 选用 has 或 is 当前缀, 如- (BOOL)hasPrefix:(NSString </em>)aString</p>

<p>Tip: 如果某个命名已经很明确了, 为了简洁可以省去类型名. 比如scores, 很明显是个array了, 就不必命名成scoreArray了</p>

<p>编码规范</p>

<p>编码规范简单来说就是为了保证写出来的代码具备三个原则:可复用, 易维护, 可扩展. 这其实也是面向对象的基本原则. 可复用, 简单来说就是不要写重复的代码, 有重复的部分要尽量封装起来重用. 否则修改文件的时候得满地找相同逻辑的地方&hellip;这个就用no zuo no die来描述吧, 哈哈&hellip;易维护, 就是不要把代码复杂化, 不要去写巨复杂逻辑的代码, 而是把复杂的逻辑代码拆分开一个个小的模块, 这也是Do one thing的概念, 每个模块(或者函数)职责要单一, 这样的代码会易于维护, 也不容易出错. 可扩展则是要求写代码时要考虑后面的扩展需求, 这个属于架构层面的东东, 利用对应的设计模式来保证, 后面有机会单独写文探讨。</p>

<p>编码规范直接通过示例来介绍, 毕竟对于程序员来说一个Demo胜过千行文字(有同感的小伙伴让我看到你们的双手, 哈哈O(∩_∩)O~~). 下面的部分示例选自richieyang博文, 写的很好的一篇文章, 推荐大家看一下, 我自己也是受益匪浅.</p>

<p>1). 判断nil或者YES/NO</p>

<p>Preferred:</p>

<pre><code>
if (someObject) { ... } 
if (!someObject) { ... }
</pre>


<p></code>
Not preferred:</p>

<pre><code>
if (someObject == YES) { ...} 
if (someObject != nil) { ...}
</pre>


<p></code>
if (someObject == YES)容易误写成赋值语句, 自己给自己挖坑了&hellip;而且if (someObject)写法很简洁, 何乐而不为呢?</p>

<p>2). 条件赋值</p>

<p>Preferred:</p>

<pre><code>
result = object ? : [self createObject];
</pre>


<p></code>
Not preferred:</p>

<pre><code>
result = object ? object : [self createObject];
</pre>


<p></code>
如果是存在就赋值本身, 那就可以这样简写, 多简洁啊, 哈哈&hellip;</p>

<p>3). 初始化方法</p>

<p>Preferred:</p>

<pre><code>
NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve"];
NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal"};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingZIPCode = @10018;
</pre>


<p></code>
第一个好处还是简洁, 第二个好处是可以防止初始化进去nil值造成crash</p>

<p>4). 定义属性</p>

<p>Preferred:</p>

<pre><code>
@property (nonatomic, readwrite, copy) NSString *name;
</pre>


<p></code>
建议定义属性的时候把所有的参数写全, 尤其是如果想定义成只读的(防止外面修改)那一定要加上readonly, 这也是代码安全性的一个习惯.</p>

<p>如果是内部使用的属性, 那么就定义成私有的属性(定义到.m的class extension里面)</p>

<p>对于拥有Mutable子类型的对象(e.g. NSString, NSArray, NSDictionary)一定要定义成copy属性. Why? 示例: NSArray的array = NSMutableArray的mArray; 如果mArray在某个地方改变了, 那array也会跟着改变. So, make sense?</p>

<p>尽量不要暴露mutable类型的对象在public interface, 建议在.h定义一个Inmutable类型的属性, 然后在.m的get函数里面返回一个内部定义的mutable变量. Why? For security as well!</p>

<p>5). BOOL赋值</p>

<p>Preferred:</p>

<pre><code>
BOOL isAdult = age > 18;
</pre>


<p></code>
Not preferred:</p>

<pre><code>
BOOL isAdult;
if (age > 18)
{
    isAdult = YES;
}
else
{
    isAdult = NO;
}
</pre>


<p></code>
为什么要这么写呢, 我不告诉你, 哈哈哈&hellip;</p>

<p>6) 拒绝死值</p>

<p>Preferred:</p>

<pre><code>
if (car == Car.Nissan)
or
const int adultAge = 18; if (age > adultAge) { ... }
</pre>


<p></code>
Not preferred:</p>

<pre><code>
if (carName == "Nissan")
or
if (age > 18) { ... }
</pre>


<p></code>
死值每次修改的时候容易被遗忘, 地方多了找起来就悲剧了. 而且定义成枚举或者static可以让错误发生在编译阶段. 另外仅仅看到一个数字, 完全不知道这个数字代表的意义. 纳尼?</p>

<p>7). 复杂的条件判断</p>

<p>Preferred:</p>

<pre><code>
if ([self canDeleteJob:job]) { ... }     
    
- (BOOL)canDeleteJob:(Job *)job
{
    BOOL invalidJobState = job.JobState == JobState.New
                          || job.JobState == JobState.Submitted
                          || job.JobState == JobState.Expired;
    BOOL invalidJob = job.JobTitle && job.JobTitle.length;
     
    return invalidJobState || invalidJob;
}
</pre>


<p></code>
Not preferred:</p>

<pre><code>
if (job.JobState == JobState.New
    || job.JobState == JobState.Submitted
    || job.JobState == JobState.Expired
    || (job.JobTitle && job.JobTitle.length))
{
    //....
}
</pre>


<p></code>
清晰明了, 每个函数DO ONE THING!</p>

<p>8). 嵌套判断</p>

<p>Preferred:</p>

<pre><code>
if (!user.UserName) return NO;
if (!user.Password) return NO;
if (!user.Email) return NO;
 
return YES;
</pre>


<p></code>
Not preferred:</p>

<pre><code>
BOOL isValid = NO;
if (user.UserName)
{   
    if (user.Password)
    {
        if (user.Email) isValid = YES;
    }
     
}
return isValid;
</pre>


<p></code>
一旦发现某个条件不符合, 立即返回, 条理更清晰</p>

<p>9). 参数过多</p>

<p>Preferred:</p>

<pre><code>
- (void)registerUser(User *user)
{
    // to do...
      
}
</pre>


<p></code>
Not preferred:</p>

<pre><code>
- (void)registerUserName:(NSString *)userName
                password:(NSString *)password 
                   email:(NSString *)email
{
     // to do...
}
</pre>


<p></code>
当发现实现某一功能需要传递的参数太多时, 就预示着你应该聚合成一个model类了&hellip;这样代码更整洁, 也不容易因为参数太多导致出错。</p>

<p>10). 回调方法</p>

<p>Preferred:</p>

<pre><code>
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</pre>


<p></code>
函数调用的可知性, 回调时被调用者要知道其调用者, 方便信息的传递, 所以建议在回调方法中第一个参数中加上调用者。</p>

<p>Well, 不知不觉已经整理了10个了, 额, 太多了, 不知道童鞋们还有木有耐心看了, 好吧, 这一段就到此为止吧, 下面写一下block的编码规范, 各位看官, 预知后事如何, 且继续look look, 哈哈&hellip;</p>

<p>Block的循环引用问题</p>

<p>Block确实是个好东西, 但是用起来一定要注意循环引用的问题, 否则一不小心你就会发现, Oh My God, 我的dealloc肿木不走了&hellip;</p>

<pre><code>
__weak typeof(self) weakSelf = self;
dispatch_block_t block =  ^{
    [weakSelf doSomething]; // weakSelf != nil
    // preemption, weakSelf turned nil
    [weakSelf doSomethingElse]; // weakSelf == nil
};
</pre>


<p></code>
如此在上面定义一个weakSelf, 然后在block体里面使用该weakSelf就可以避免循环引用的问题. 那么问题来了&hellip;是不是这样就完全木有问题了? 很不幸, 答案是NO, 还是有问题。问题是block体里面的self是weak的, 所以就有可能在某一个时段self已经被释放了, 这时block体里面再使用self那就是nil, 然后&hellip;然后就悲剧了&hellip;那么肿么办呢?</p>

<pre><code>
__weak typeof(self) weakSelf = self;
myObj.myBlock =  ^{
    __strong typeof(self) strongSelf = weakSelf;
    if (strongSelf) {
      [strongSelf doSomething]; // strongSelf != nil
      // preemption, strongSelf still not nil
      [strongSelf doSomethingElse]; // strongSelf != nil
    }
    else {
        // Probably nothing...
        return;
         
    }
};
</pre>


<p></code>
解决方法很简单, 就是在block体内define一个strong的self, 然后执行的时候判断下self是否还在, 如果在就继续执行下面的操作, 否则return或抛出异常.</p>

<p>什么情况下会出现block里面self循环引用的问题? 这个问题问的好, 哈哈&hellip;简单来说就是双边引用, 如果block是self类的property (此时self已经retain了block), 然后在block内又引用了self, 这个情况下就肯定会循环引用了&hellip;</p>

<p>P.S. RAC里面有定义好的@weakify(self)和@strongify(self), 用起来灰常灰常的方便, 劝君尝试一下^_^</p>

<p>那些年遇到的Crash</p>

<p>多线程同步问题造成的Crash
这个其实还蛮常见的, 尤其是在多线程泛滥使用的今天&hellip;你可以使用多线程, 但你要知道保护它呀, 哈哈. 对于数据源或model类一定要注意多线程同时访问的情况, 我个人比较喜欢用GCD的串行队列来同步线程.</p>

<p>Observer的移除
现在的代码里面很多需要用到Observer, 根据被观察对象的状态来相应的Update UI或者执行某个操作. 注册observer很简单, 但是移除的时候就出问题了, 要么是忘记移除observer了, 要么是移除的时机不对. 如果某个被观察对象已经被释放了, observer还在, 那结果只能是crash了, 所以切记至少在dealloc里面移除一下observer&hellip;</p>

<p>NSArray, NSDictionary成员的判空保护
在addObject或insertObject到NSArray或者NSDictionary时最好加一下判空保护, 尤其是网络相关的逻辑, 如果网络返回为空(jason解析出来为空), 但你还是毅然决然的add到array里面, 那么&hellip;</p>

<p>最后一点就是commit代码之前一定要保证木有warning, 木有内存泄露, 确保都OK之后再上传代码. 其实很简单, 上传代码之前Command + Shift + B静态分析一下, 看看有木有什么issue&hellip;就先写这么多吧, 以后遇到更多的坑后, 我一定会爬出来再过来补充的, to be continued&hellip;</p>

<p>References:</p>

<p><a href="http://www.cnblogs.com/richieyang/p/4840614.html">http://www.cnblogs.com/richieyang/p/4840614.html</a></p>

<p><a href="http://blog.xcodev.com/archives/objective-c-naming/">http://blog.xcodev.com/archives/objective-c-naming/</a></p>

<p><a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 张昊煜 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
